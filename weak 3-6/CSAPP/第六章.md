# 存储器层次结构

## 局部性

CPU的工作要高速，我们希望CPU需要的数据更多的就在L1里面，一找就找着。不希望更多的跑到下面内存乃至磁盘里面去找，这样会花更多的时间。所以当CPU用了一个数据，计算机会遇见性的存入其他等会儿CPU可能会用到的数据到L123内存，用到的可能性越大，就能存到越接近寄存器的层次。这也才是缓存的真正意义。那么，计算机怎样才能判断一个数据接下来可能被用到？

时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。
这当然是正确的，用过的数据当然可能再次被用到。

空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。
正在使用的这个数据地址旁边的数据，当然也是很可能被用到的。比如数组什么的

程序举例：

```
int sumvec(int v[N]){
	int i, sum=0;
	
	for(i=0;i<N;i++){
		sum += v[i];
	}
	return sum;
}
```

这段代码对于数组v是连续访问的步长为1，就是将来用到的信息是和现在正在使用的信息是临近的，所以有良好的空间局部性。对于sum他则是具有良好的时间局部性，近期访问多次，所以说这个函数拥有良好的局部性

```
int sumarrayrows(int a[M][N]){
	int i, j, sum=0;
	
	for(i=0;i<M;i++){
		for(j=0;j<N;j++){
			sum += v[i][j];
		}		
	}
	return sum;
}
```

二位数组在内存中也是按行存储的所以也拥有良好的空间局部性所以说这个函数也拥有良好的局部性

```
int sumarrayrows(int a[M][N]){
	int i, j, sum=0;
	
	for(i=0;i<M;i++){
		for(j=0;j<N;j++){
			sum += v[i][j];
		}		
	}
	return sum;
}
```

这个函数就没有良好的局部性了，因为这个是按列来访问的，即每次都是跨行访问的，访问的并不是临近的元素，所以没有良好的空间局部性

**取指令的局部性**

因为指令也是放在内存中的，需要取出这些指令，才能执行，for里的指令是按照连续的内存顺序执行的，所以说for拥有良好的空间局部性。同时因为循环会被执行多次，所以说也拥有良好的时间局部性

## 存储器层次结构

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-26_11-47-09.png)

这个图就很清楚的表明了存储器的层次结构

**缓存命中**

缓存命中举个例子就是我要取A这个数据，然后取下层存储器找，下层存储器就有这个A，就可以直接拿来使用，就是缓存命中

**缓存不命中**

缓存不命中，还是上面的例子，就是我要A下层没有，就是没有命中，下层就再去下层找，还有就是如果说下层缓存满了，他从下下层取出来的没有位置放，就需要替换或者叫驱逐一个块。驱逐哪个块是有不同的方法的，是由替换策略决定的，随机替换策略就直接随机替换一个块，LRU策略就是寻找最后一次使用举例现在时间最长的块，替换掉他。

**缓存不命中分类**

冷不命中：即缓存是空的，什么都访问不到

冲突不命中：即下层的不同的块映射到了上层的同一个块上，如果我要就是要取前面的两个不同的块但是映射到了上层同一个块上的块，就会导致我取完第一个块，再取第二个块的时候，会把第一个块覆盖，就需要再取第一个。这样就算冲突不命中

容量不命中：就是缓存太小了，不够处理这个工作集

## 高速缓存存储器

每个存储器有m位地址，就会有M=2^m个不同的地址。

一个高速缓存有S=2^s个组，每组有E行，每行由B=2^b字节的数据块组成。

其中s是组索引位有多少位，b是块偏移位有多少位，m是地址位有多少位

用下面的图表示就是

```
地址：
	----------------------------------------------------------------
	|  tag(标记位)  |  set index(组索引位)  |  block offset(块偏移位)  |
	----------------------------------------------------------------
	
cache：

	组0：
	
	----------------------------------------------------------------
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------	  |--->
	----------------------------------------------------------------	  |--->  E行
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------
	
	组1：
	
	----------------------------------------------------------------
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------	  |--->
	----------------------------------------------------------------	  |--->  E行
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------
			
	...................
	
  组s-1：
  
  	----------------------------------------------------------------
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------	  |--->
	----------------------------------------------------------------	  |--->  E行
	|  valid(有效位)  |  tag(标记位)  |0|1|2|3|4..................|B-1|------
	----------------------------------------------------------------
  
```

### 直接映射高速缓存

简单来说就是E等于1，即每组一行

根据地址位，就是通过s确定组索引，然后判断是哪一行，因为直接映射高速缓存只有一行所以就会直接匹配一行，然后通过b来确定快偏移。

不命中的时候就直接行替换，不用考虑替换那一行因为就只有一行所以就直接用新行替换旧的哪一行就可以了

不过由于是只有一行在超过了cache的组的大小之后，再次使用就会替换掉第一行的cache就会导致冲突不命中

### 组相连高速缓存

简单来说就是E等于2，即每组两行

确定组和直接映射高速缓存一致，确认行就有一些变化了，直接映射高速缓存只有一行所以直接确认那一行就可以了，而组相联告诉缓存有两行所以就需要判断以下要使用哪一行，这就用到了标记位和有效位，就取标记位和有效位相同的哪一行

如果不命中，就需要替换了，替换的时候就需要使用对应的替换策略了。

### 全相联高速缓存

简单来说只有一组

组选择和上面两种告诉缓存不一样的是只有一组直接选择这组就可以了，行匹配也是通过标记位和有效位来确定的，而且全相联高速缓存中没有s位，而是把s位合并到了tag位，即下面这种形式

```
地址：
	----------------------------------------------------------------
	|             tag(标记位)              |  block offset(块偏移位)  |
	----------------------------------------------------------------
```

