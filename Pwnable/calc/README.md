首先来看程序的逻辑，程序大体逻辑在这几行代码里，首先获取咱们输入的式子，然后解析式子计算出结果，然后输出结果，这里需要注意以下`v2[v1 - 1]`这里会取v1的值作为v2的下标，如果说v1的值可控那么就可以通过这个洞来在修改栈上的内容从而可以控制程序执行流程

```
while ( 1 )
{
  bzero(&s, 0x400u);
  if ( !get_expr(&s, 0x400) )
    break;
  init_pool(&v1);
  if ( parse_expr(&s, &v1) )
  {
    printf(&d, v2[v1 - 1]);
    fflush(stdout);
  }
}
```

具体来看以下解析表达式函数的代码，其中v9是存储运算的数字的，第一次运行到这里时number_buf的值为0，所以此时number_buf[1]=运算的数字中的一个，number_buf存储运算的数字是连续存储的，比如说5+10，那么number[1]=5，number[2]=10，然后number[0]会存储输入了几个数字

```
v9 = atoi(char_number_buf);
if ( v9 > 0 )
{
  v4 = (*number_buf)++;
  number_buf[v4 + 1] = v9;
}
```

后面就会根据输入的运算符执行对应的运算，对应代码如下，这里num1[0]对应的就是number[0]，现再还是对5+10这个式子进行分析，可以得到这样的结果，num1[1] = num[1]+ num1[2] = 5 + 10 = 15

```
_DWORD *__cdecl eval(_DWORD *num1, char symbol)
{
  _DWORD *result; // eax

  if ( symbol == '+' )
  {
    num1[*num1 - 1] += num1[*num1];
  }
  else if ( symbol > '+' )
  {
    if ( symbol == '-' )
    {
      num1[*num1 - 1] -= num1[*num1];
    }
    else if ( symbol == '/' )
    {
      num1[*num1 - 1] /= num1[*num1];
    }
  }
  else if ( symbol == '*' )
  {
    num1[*num1 - 1] *= num1[*num1];
  }
  result = num1;
  --*num1;
  return result;
}
```

乍一看没有什么问题，但是当我们第一个输入的是运算符而不是数字时就会产生问题，比如说输入的是"+100"，对应这个式子只有在检测到了100的是时候才会经过这个分支，那么就会使number_buf[1]=100，然后number_buf[0]=1，对应执行运算的时候，就会是num1[0] = num[0]+ num1[1] = 1+100 = 101，这样我们就控制了number_buf的第一个数字，这样我们就可以控制v2的数组下标，也就代表我们现再可以越界了

```
v9 = atoi(char_number_buf);
if ( v9 > 0 )
{
  v4 = (*number_buf)++;
  number_buf[v4 + 1] = v9;
}
```

这里我们可以找到int 0x80这条指令，所以我们就直接构造execve函数需要的参数，构造参数通过gadget来构造，然后通过越界修改程序返回地址，从而控制程序执行流程，参数都构造结束之后，就转去执行int 0x80这条指令，就可以拿到shell了

我们需要设置4个寄存器的值，eax，ebx，ecx，edx，eax应该是系统调用号11，ebx应该是/bin/sh字符串的地址，ecx和edx为0即可，在动调的时候可以发现edx的值已经就是0了所以说可以不用再设置edx了，对应我们就应该在栈上构造这样的结构

``` 
---------------------------------
|      addr : pop eax; ret      |
---------------------------------
|              11               |
---------------------------------
|  addr : pop ecx; pop ebx ret  |
---------------------------------
|              00               |
---------------------------------
|       addr : "/bin/sh"        |
---------------------------------
|           int 0x80            |
---------------------------------
|            "/bin"             |
---------------------------------
|           "/sh\00"            |
---------------------------------
```

然后我们发送一个错误的表达式，就可以跳去执行execve了，就拿到shell了