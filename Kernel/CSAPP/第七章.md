# 链接

## 预处理

预处理主要做这些事情

1. 删除'#define'并展开所定义的宏
2. 处理所有条件预编译指令，如'#if'，'#ifdef'，'#endif'等
3. 插入头文件到'#include'处，可以递归方式进行处理
4. 删除所有的注释
5. 添加行号和文件名标识，以便编译时编译器产生调试用的行号信息
6. 保留所有#pragma编译指令

经过预处理之后，得到的是预处理文件（后缀为.i），它还是一个可读的文本文件，但是没有任何的宏定义

## 编译

编译就已经说过好多次了，词法分析，语法分析，语义分析，优化，生成汇编代码

## 汇编

把编译的生成的汇编代码转换成机器语言

## 链接

将多个可重定位目标文件合并以生成可执行目标文件，就是你的代码里调用了库函数，所以就需要把库函数也加到代码里才可以调用你使用的库函数

链接操作的具体步骤

1. 符号解析

   - 程序中由定义和引用的符号（包括变量和函数）

   - 编译器将定义的符号存放在一个符号表中

   - 编译器将符号的引用存放在重定位节中

   - 链接器将每个符号的引用都与一个确定的符号定义建立关联
2. 重定位
   - 将多个代码段与数据段分别合并为一个单独的代码段和数据段
   - 计算每个定义的符号在虚拟地址空间中的绝对地址
   - 将可执行文件中的符号引用处的地址修改为重定位后的地址信息，也就是修改为合并后得到的绝对地址

### 符号解析

**符号解析的具体过程**

有三个集合

```
E将合并一组成可执行文件的所有目标文件集合
U当前所有为解析的引用符号的集合
D当前所有定义符号的集合
```

举一个例子

```
main.c

void myfunc1(void);
int main(){
	myfunc1();
	return 0;
}
-----------------------------------
myproc1.c

#include <stdio.h>

void myfunc1(){
	printf("this is myfun1!\n");
}
-----------------------------------
myproc2.c

#include <stdio.h>

void myfunc2(){
	printf("this is myfun2!\n");
}
```

然后使用gcc链接，gcc -static -o myproc main.o ./mylib.a

一开始E、U、D为空，首先扫描main.o，把它加入E，同时把myfun1加入U，main加入D。接着扫描到mylib.a，将U中所有符号（本例中为myfunc1）与mylibc.a中所有目标模块（myproc1.c和myproc2.c）进行匹配，发现在myproc1.c中定义了myfunc1，然后就把myfunc1.o加入E，myfunc1从U转移到D。在myproc.o中发现还有没有解析的printf，就把printf放进U中。不断再mylib.a的各模块上进行迭代以匹配U中的符号，直到U、D都不再变化。此时U中只有一个为解析符号printf，而D中有main和myfunc1。因为模块myproc2.o没有被加入E中，所以被丢弃。

然后因为U中还有未定义的printf，所以就扫描默认的库文件libc.a，发现其目标模块printf.o定义了printf，就把printf移到D中，并将printf.o加入E，同时把它定义的所有符号加入D，而所有为解析符号加入U，处理完libc.a时，U一定时空的

**链接的顺序**

1. 按照命令行给出的顺序扫描.o和.a文件
   - 注1：命令行能否正确解析与命令行给出的顺序有关
   - 注2：好的做法时将静态库放在命令行的最后
2. 扫描期间将当前未解析的引用记录到一个列表U中
3. 每当遇到一个新的.o或.a中的模块，都试图用其来解析U中的符号
4. 如果扫描到最后，U中还有违背解析的符号，则发生错误

### 重定位

**重定的步骤**

1. 合并相同的节
   - 将集合E的所有目标模块中相同的节合并成新节
2. 对集合D中的定义符号进行重定位（确定地址）
   - 确定新节中所有定义符号在虚拟地址空间中的地址
3. 对引用符号进行重定位（确定地址）
   - 修改.text节和.data节中对每个符号的引用（地址），需要用到在.rel_data和.rel_text节中保存的重定位信息

**重定位信息**

数据引用的重定位条目在.rel_data节中

指令中引用的重定位条目在.rel_text节中

重定位是把符号引用与符号定义连接在一起的过程。比如，当程序调用一个函数时，将从当前运行的指令跳转到一个新的指令地址去执行。在编写程序的时候，我们只需指明所要调用的函数名（即符号引用），在重定位的过程中， 函数名会与实际的函数所在地址（即符号定义）联系起来，使程序知道应该跳转到哪里去。 重定位文件必须知道如何修改其所包含的“节”的内容，在构建可执行文件或共享目标文件的时候，把节中的符号引用换成这些符号在进程空间中的虚拟地址。 包含这些转换信息的数据也就是重定位项。

重定位项结构

```
typedef struct {
 Elf32_Addr r_offset;
 Elf32_Word r_info;
} Elf32_Rel;

typedef struct {
 Elf32_Addr r_offset;
 Elf32_Word r_info;
 Elf32_Sword r_addend;
} Elf32_Rela; 
```

 r_offset：给出重定位所作用的位置。对于重定位文件来说，此值是受重定位作用的存储单元在节中的字节偏移量；对于可执行文件或共享目标文件来说，此值是受重定位作用的存储单元的虚拟地址。
 r_info：本数据成员既给出了重定位所作用的符号表索引，也给出了重定位的类型。
 r_addend：本成员指定了一个加数，这个加数用于计算需要重定位的域的值。

Elf32_Rela 与 Elf32_Rel 在结构上只有一处不同，就是前者有r_addend。 Elf32_Rela 中是用 r_addend 显式地指出加数；而对 Elf32_Rel 来说，加数是隐含在被修改的位置里的。Elf32_Rel 中加数的形式这里并不定义，它可以依处理器架构的不同而自行决定。在特定处理器上如何实现，可以指定一种固定的格式，也可以不指定格式而依据上下文来解析。

###  静态链接

静态链接对象：多个可重定位目标模块+静态库（标准库、自定义库）

静态库

1. 将所有相关的目标模块(.o)打包为一个单独的库文件(.a)，称为静态库文件，也称存档文件
2. 可将经常使用的函数模块放到静态函数库中，以供调用
3. 使用静态库，可增强链接器功能，使其能通过查找一个或多个库文件中定义的符号来解析符号
4. 在构建可执行文件时，只需指定库文件名，连接器会自动到库中寻找那些应用程序用到的目标模块，并且只把用到的模块从库中拷贝出来，链接到可执行文件中

## 虚拟内存

```
------------------------
|      内核虚存区        |
------------------------
|     栈（动态生成）      |
-------------------------   <- esp
|          ↓            |
|          ↑            |
-------------------------
|       共享库区域        |
-------------------------
|          ↓            |
|          ↑            |
-------------------------   <- brk
|          堆           |
-------------------------
|       读写数据段        |
-------------------------
|       只读代码段        |
-------------------------
|         未使用         |
-------------------------
```

## 目标文件

### 可重定位目标文件

其代码和数据可和其它可重定位文件合并为可执行文件

每个.o文件由对应的.c文件生成

每个.o文件代码和数据地址都从0开始

**文件格式如下**

|        ELF头         |
| :------------------: |
|       .text节        |
|      .rodata节       |
|       .data节        |
|        .bss节        |
|      .symtab节       |
|      .rel.txt节      |
|     .rel.data节      |
|       .debug节       |
|      .strtab节       |
|       .line节        |
| Section header table |

**ELF头的结构**

```
typedef struct {
    unsigned char   e_ident[EI_NIDENT];	
    ELF32_Half      e_type;		
    ELF32_Half      e_machine;
    ELF32_Word      e_version;
    ELF32_Addr      e_entry;
    ELF32_Off       e_phoff;
    ELF32_Off       e_shoff;
    ELF32_Word      e_flags;
    ELF32_Half      e_ehsize;
    ELF32_Half      e_phentsize;
    ELF32_Half      e_phnum;
    ELF32_Half      e_shentsize;
    ELF32_Half      e_shnum;
    ELF32_Half      e_shstrndx;
} Elf32_Ehdr;
```

其中第一个e_ident[EI_NIDENT]，还可以根据下标分成

```
EI_MAG0
EI_MAG1
EI_MAG2
EI_MAG3
EI_CLASS
EI_DATA
EI_VERSION
EI_PAD
EI_NIDENT
```

EI_MAG0-EI_MAG3：固定前四个字节为0x7f,0x45,0x4C,0x46,也就是0x7f,'ELF'

EI_CLASS：文件类型32位还是64位

EI_DATA：大端还是小端

EI_VERSION：指明ELF文件头的版本

EI_PAD：填充EI_PAD到EI_NIDENT-1中间的字节为0

EI_NIDENT：也是填充字节

e_ident[EI_NIDENT]就占了前16个字节

e_type：目标文件属于哪种类型，比如是可执行文件还是可重定位文件等

e_machine：处理器体系结构

e_version：目标文件的版本

e_entry：代码加载的虚拟地址

e_phoff：程序头表在文件中的偏移量

e_shoff：节头表在文件中的偏移量

e_flags：处理器特定的标志为

e_ehsize：ELF文件头的大小，以字节为单位

e_phentsize：表明在程序头表中每一个表项的大小，每一个表项大小是相同的

e_phnum：表明程序头表中的项数

e_shentsize：表明在节头表中每一个表项的大小，每一个表项大小是相同的

e_shnum：表明在节头表中的项数

e_shstrndx：节头表中与节名字表相对应的表项的索引

------

.text节：存放程序指令代码

.rodata节：包含程序中的只读数据，程序装载时他们会被装入进程空间中那些只读的段中去

.data节：存放程序中已经初始化过的全局变量

.bss节：包含目标文件中为初始化的全局变量。一般情况下，可执行程序在开始运行的时候，系统会把这一段内容清零。但是，在运行期间的bss段是由系统初始化而成的，在目标文件中.bss节并不包含任何内容，其长度为0。但是会在节头表中来指明应该给bss段预留多大的空间

.symtab节： 用来存放符号表，存放函数名和全局变量信息

.rel.txt节：text段的重定位，用于重新修改代码段的指令中的地址信息

.rel.data节： data段的重定位，用于对被模块使用或定义的全局变量进行重定位的信息

.debug节：保存调试信息

.strtab节：用来存放字符串，主要是那些符号表项的名字

.line节：包含调试符号的行号，为程序指令码与源文件的行号建立起联系

Section header table（节头表）：每个节的节名、偏移和大小，节头表的每一个表项都是一个ELF32_Shdr结构，通过每一个表项可以定位到对应的节，每个表项占40字节

节头表中每一项的结构

```
typedef struct {
 Elf32_Word sh_name;
 Elf32_Word sh_type;
 Elf32_Word sh_flags;
 Elf32_Addr sh_addr;
 Elf32_Off sh_offset;
 Elf32_Word sh_size;
 Elf32_Word sh_link;
 Elf32_Word sh_info;
 Elf32_Word sh_addralign;
 Elf32_Word sh_entsize;
} Elf32_Shdr;
```

 sh_name：本节的名字，这里存储的也不是字符串，而是存储的一个索引，这个索引对应着字符串表中的某个位置，那个位置存储着这个节的字符串名字以\0为结尾

 sh_type：本节的类型

 sh_flags：本节的一些属性，由一系列标志比特位组成，各个比特定义了节的不同属性，当某种属性被设置时，相应的标志位被设为1，反之设为0.未定义的标志为全部置为0

 sh_addr：如果本节的内容需要映射到进程空间中去，此成员指定映射的起始地址：如果不需要映射，此值为0

 sh_offset：指明了本节所在的位置，该值时节的第一个字节在文件中的位置，即相对于文件开头的偏移量。单位是字节。

 sh_size：节的大小，单位是字节

 sh_link：一个索引值，指向头节表中本节对应的位置

 sh_info：此节的附加信息，根据节的类型不同，本成员的意义也有所不同

 sh_addralign：指明本节内容如何对齐字节，即该节的地址应该向多少个字节对齐

 sh_entsize：有一些节的内容是一张表，其中每一个表项的大小时固定的，比如符号表。对于这种表来说，本成员指定其每一个表项的大小。如果此值为0则表明本节内容不是这种表格，简单来说就是鉴定本节是不是符号表那样的节

### 可执行目标文件

例如windows下的exe程序

包含的代码和数据可以直接复制到内存并被执行（已初始化.data和未初始化.bss）

定义的所有变量和函数已有确定地址（虚拟地址空间中的地址）

符号引用处已被重定位，以指向所引用的定义符号

没有文件扩展名或默认为a.out

可被CPU直接执行，指令地址和指令给出的操作数地址都是虚拟地址

代码和数据地址为虚拟地址空间中的地址

**文件格式如下**

|        ELF头         |
| :------------------: |
|       程序头表       |
|       .init节        |
|       .text节        |
|      .rodata节       |
|       .data节        |
|        .bss节        |
|      .symtab节       |
|       .debug节       |
|      .strtab节       |
|       .line节        |
| Section header table |

和可重定位目标文件不一样，其中多了一个程序头表和一个.init表，少了两个重定位表，少了重定位表时因为可执行目标文件对应的节都是已经写好了的，链接的时候不需要重定位，而可重定位目标文件链接后需要重定位才有的重定位表

程序头表：程序头表是一个数组，数组中的每一个元素被称为程序头，每一个程序头描述了一个段或者一块用于准备执行程序的信息。一个目标文件中的段包含一个或多个节

程序头的结构

```
typedef struct {
 Elf32_Word p_type;
 Elf32_Off p_offset;
 Elf32_Addr p_vaddr;
 Elf32_Addr p_paddr;
 Elf32_Word p_filesz;
 Elf32_Word p_memsz;
 Elf32_Word p_flags;
 Elf32_Word p_align;
} Elf32_Phdr;
```

 p_type：说明本程序头所描述的段的类型

 p_offset：说明本段在文件中的偏移

 p_vaddr：指出本段内容的开始位置在进程空间中的虚拟地址

 p_paddr：给出本段内容的开始位置在进程空间中的物理地址。对于目前大多数现代操作系统而言，应用程序中段的物理地址事先是不可知的，所以目前这个成员多数情况下保留不用，或者被操作系统改作他用

 p_filesz：本段的大小

 p_memsz：本段内容在内容镜像中的大小

 p_flags：本段的属性

 p_align：指明本段如何在内存和文件中对齐

------

.init节：此节包含进程初始化时要执行的程序指令。当程序开始运行时，系统会在进入主函数之前执行这一节中的代码。主函数指的时main函数。

------

**可执行文件的存储器映像**

|            内核续存区            |
| :------------------------------: |
|         用户栈  动态生成         |
|                ↓                 |
|                ↑                 |
|            共享库区域            |
|                ↑                 |
|                堆                |
|     读写数据段（.data,.bss）     |
| 只读代码段（.init,.text,rodata） |
|              未使用              |

### 共享的目标文件

动态链接的时候使用，能在装入或运行时被动态的装入到内存并自动被链接

windows下就是dll文件

## 目标文件的格式

目标代码：指编译器和汇编器处理源代码后所生成的机器语言目标代码

目标文件：指包含目标代码的文件

## 符号和符号表

链接操作的具体步骤

1. 符号解析

   - 程序中由定义和引用的符号（包括变量和函数）

   - 编译器将定义的符号存放在一个符号表中

   - 编译器将符号的引用存放在重定位节中

   - 链接器将每个符号的引用都与一个确定的符号定义建立关联
2. 重定位
   - 将多个代码段与数据段分别合并为一个单独的代码段和数据段
   - 计算每个定义的符号在虚拟地址空间中的绝对地址
   - 将可执行文件中的符号引用处的地址修改为重定位后的地址信息，也就是修改为合并后得到的绝对地址

**符号可以分成三种**

1. 全局符号

   由模块m定义并能被其它模块引用的符号。例如，非static C函数和非static的C全局变量（指不不带static的全局变量）

   例如C语言在main函数里定义一个int a,啊就是一个全局变量名

2. 外部符号

   由其它模块定义并被模块m引用的全局符号

   例如C语言在main函数里调用swap函数，然后swap函数中有一个变量名为buf，swap和buf就是外部符号

3. 局部符号

   仅由模块m定义和引用的本地符号

   例如，在模块m中定义的带static的C函数和变量

**符号表**

符号表所包含的信息用于定位和重定位程序中 的符号定义和引用。目标文件的其它部分通过一个符号在这个表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项（即第一项）并没有实际的意义， 它表示未定义的符号。

符号表项的结构

```
typedef struct {
 Elf32_Word st_name;
 Elf32_Addr st_value;
 Elf32_Word st_size;
 unsigned char st_info;
 unsigned char st_other;
 Elf32_Half st_shndx;
} Elf32_Sym; 
```

 st_name：符号的名字。不过它也是一个索引，并不是一个字符串，这个索引指向字符串表的索引值，在 字符串表中对应位置上的字符串就是该符号名字的实际文本

 st_value：符号的值。这个值没有固定的类型，它可能代表一个数值，也可以是一个地址，具体是什么要看上下文

 st_size：符号的大小

 st_info：符号的类型和属性

 st_other：暂未使用，为0

 st_shndx：是一个索引值，指向相关联的节在借由表中的索引。在重定位过程中，节的位置会改变，本数据成员的值也随之改变，继续指向节的新位置。

符号表的第一项它的内容与其他项不同，内容如下

| 名字     | 值        | 意义     |
| -------- | --------- | -------- |
| st_name  | 0         | 无效名字 |
| st_value | 0         | 0值      |
| st_size  | 0         | 无效大小 |
| st_info  | 0         | 无效类型 |
| st_other | 0         |          |
| st_shndx | SHN_UNDEF | 无对应节 |

**全局符号的强、弱**

函数名和已初始化的全局变量名时强符号

未初始化的全局变量名时弱符号

**多重定义符号的处理规则**

1. 强符号不能被多次定义
2. 若一个符号被定义为一次强符号和多次弱符号，则按强定义为准
3. 若有多个弱符号定义，则任选其中一个

符号解析时只能有一个确定的定义（即每个符号仅占一处存储空间）

一定要使用全局变量的情况下，要遵守以下规则

1. 尽量使用本地变量（static）,模块内引用不太会出错
2. 全局变量要赋初值，让他成为强符号，易查出链接错误
3. 外部全局变量使用extern，以示其引用的定义在其他模块

## 可执行文件的加载

虚拟地址存储空间

```
------------------------
|      内核虚存区        |
------------------------
|     栈（动态生成）      |
-------------------------   <- esp
|          ↓            |
|          ↑            |
-------------------------
|       共享库区域        |
-------------------------
|          ↓            |
|          ↑            |
-------------------------   <- brk
|          堆           |
-------------------------
|       读写数据段        |
-------------------------
|       只读代码段        |
-------------------------
|         未使用         |
-------------------------
```

以hello程序为例

1. 在shell命令行提示符后输入命令
2. shell命令行解释器构造argv和envp
3. 调用fork函数，创建一个子进程，与父进程shell完全相同，包括制度代码段，可读写数据段、堆以及用户栈等
4. 调用execve函数，在当前进程的上下文中加载并运行hello程序。将hellp中的.text、.data、.bss等内容加载到当前进程的虚拟地址空间（仅修改当前进程上下文中关于存储映像的一些数据结构，不从磁盘拷贝代码、数据等内容），最终转去执行main

关于在mian函数之前，调用了哪些函数

![](https://ctf-wiki.github.io/ctf-wiki/executable/elf/figure/program-running-overview.png)

这个图就很详细了，在执行main函数前会先执行一些函数，主要的顺序就是_start -> _libc_stratmain -> libc_csu_int -> atextit -> main

## 共享库

共享库包含目标模块的文件，每个模块含有代码和数据

从程序中分离出来，磁盘和内存中都只有一个备份

可以在装入时或运行时动态地被加载并链接

**两种运行方式**

1. 第一次加载时进行
   - 由动态连接器自动处理
2. 开始运行后进行
   - 通过调用dlopen等接口来实现

程序头表中有.interp段，其中包含了动态连接器路径名ld-linux.so

**位置无关代码**

共享库代码被加载的位置可以时不确定的

即使共享库代码的长度发生变化，也不影响调用它的程序

**共享库内所有引用情况**

1. 模块内的过程调用、跳转，采用PC相对偏移寻址
2. 模块内数据访问，如访问模块内的全局变量和静态变量
3. 模块外的过程调用、跳转
4. 模块外的数据访问，如外部变量的访问

**模块间调用、跳转**

got表，got表中存储的是指针，指针指向的是要调用的函数的首地址，重定位的时候会修改这个值

延迟绑定：加载时不重定位，第一次调用的时候才重定位。

GOT 表的初始值都指向 PLT 表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT 表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。整个过程如下面两张图所示。

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-05-08_14-54-01.png)

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-05-08_14-59-48.png)

```
GOT数组的含义
GOT[0]	为.dynamic节首地址，该节中包含动态连接器所需要的基本信息，如符号表位置、重定位表位置等
GOT[1]	为动态链接器的标识信息
GOT[2]	为动态链接器延迟绑定代码的入口地址
GOT[3]	对应调用的函数

PLT数组的含义
PLT[0]的作用是把GOT[1]的内容压入栈里，并转去调用GOT[2]处所指向的代码
PLT[1]以及之后的每一个都对应一个调用的函数

用这种方式就更容易理解了，函数运行call的时候会转到plt表所指向的代码处，如果是第一次调用这个函数就会直接跳转到调用的这个函数的got表指向的代码，由于是第一次调用got表指向的代码其实就是跳转代码的吓一跳指令，就又回到plt表这里了，然后执行压栈指令，压的是调用函数的id，然后跳转到PLT[0]的代码处，PLT[0]处的代码主要就是把GOT[1]的内容压入栈，然后跳转到GOT[2]的代码处，GOT[2]为动态链接器延迟绑定代码的入口地址，也就会直接去调用动态链接器了，此时栈顶就是动态链接器的标识信息和调用函数的id，动态连接器会根据这两个信息找到调用函数的地址并且把这个地址装填到对应的GOT表中去，下一次再调用的时候还是会从plt表跳到got表，不过这回就直接执行got表中的代码了，而不会直接跳到下一条指令了
```

