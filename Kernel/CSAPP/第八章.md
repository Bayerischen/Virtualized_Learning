# 异常控制流

## 异常

异常：控制流中的突变，用来相应处理器状态中的某些变化

处理器正在执行当前指令同时处理器状态发生一个重要的变化（状态变化称为事件，时间可能与当前指令相关也可能不相关）

处理器检测到有时间发生就会通过异常表进行一个间接过程调用（异常），到一个专门设计用来处理这类时间的操作系统子程序（异常处理程序）。

**异常处理程序处理完成后，会根据异常的时间的类型的不同，出现三种不同的结果**

1. 处理程序将控制返回当前指令，即当事件发生时正在执行的指令
2. 处理程序将控制返回给下一条指令，如果没有发生异常就会执行的下一条指令
3. 处理程序终止被终端的程序

### 异常处理

异常号：每种类型异常都有一个非负整数的异常号，一部分由处理器设计者分配，一部分由操作系统内核的设计者分配，前者的示例包括被0除，缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部的I/O设备的信号

异常表：其实感觉和got表类似，保存着对应程序的地址，属于一个跳转表，系统启动时分配

异常表的使用过程如下

```
					   --------------
					   | 异常号（x84）|
					   --------------
							  |
							  V						  异常表
-----------------			-----				----------------
| 异常表基址寄存器 |---------> | + |----------->  0|			  |
-----------------			-----			    -----------------
											   1|			    |
											    -----------------
											   2|			    |
											    -----------------
											    		。
											    		。
											    		。
											    -----------------
											 n-1|			    |
											    -----------------
											   
```

异常表基址寄存器是来存异常表的起始地址的，加上异常号的偏移就可以指向对应的异常处理程序地址了

**异常与过程调用的不同：**

1. 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令，要么是下一条指令
2. 处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态
3. 如果控制从用户转到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中
4. 异常处理程序运行在内核模式下，意思就是异常处理程序对所有的系统资源都有访问的权限

硬件触发异常，就由异常处理程序在软件中完成。完成后，执行一条特殊的从中断返回指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序们就将状态恢复为用户模式，然后将控制返回给被中断的程序

### 异常的类别

| 类别 | 原因              | 异步/同步 | 返回行为             |
| ---- | ----------------- | --------- | -------------------- |
| 中断 | 来自I/O设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常        | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误    | 同步      | 不会返回             |

**中断**

用一张图就可以表示了，还有就是中断是异步发生的，是来自处理器外部的I/O设备的信号的结果

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-27_22-41-41.png)

**陷阱和系统调用**

陷阱是有意的异常，系统调用就是陷阱，用途就是提供用户程序与内核之间像过程一个的接口，图示如下

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-27_22-43-12.png)

系统调用可以执行特权指令，并访问定义在内核中的栈

**故障**

故障由错误情况引起，它有可能被故障处理程序修正。发生故障时并不会直接终止掉发生故障的进程，而是尝试取修复，如果修复成功就返回下一条指令，反之不成功就返回到内核中的abort例程，abort例程会终止引起故障的程序，图示如下

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_22-07-13.png)

**终止**

终止处理程序处理完成后就直接返回到abort例程，然后就直接终结这个程序

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-27_22-47-05.png)

**linux/x86-64系统中的异常**

其实对应的故障也接触过，段故障，做pwn的时候如果开了NX返回到栈上执行指令就会出现段故障

异常示例表

| 异常号 | 描述               | 异常类别   |
| ------ | ------------------ | ---------- |
| 0      | 除法错误           | 故障       |
| 13     | 一般保护故障       | 故障       |
| 14     | 缺页               | 故障       |
| 18     | 机器检查           | 终止       |
| 32~255 | 操作系统定义的异常 | 中断或陷阱 |

系统调用示例表

| 编号 | 名字  | 描述               | 编号 | 名字   | 描述                 |
| ---- | ----- | ------------------ | ---- | ------ | -------------------- |
| 0    | read  | 读文件             | 33   | pause  | 挂起进程直到信号到达 |
| 1    | write | 写文件             | 37   | alarm  | 调度告警信号的传送   |
| 2    | open  | 打开文件           | 39   | getpid | 获得进程ID           |
| 3    | close | 关闭文件           | 57   | fork   | 创建进程             |
| 4    | stat  | 获得文件信息       | 59   | execve | 执行一个程序         |
| 9    | mmap  | 将内存页映射到文件 | 60   | _exit  | 终止进程             |
| 12   | brk   | 重置堆顶           | 61   | wait4  | 等待一个进程终止     |
| 32   | dup2  | 复制文件描述符     | 62   | kill   | 发送信号到一个进程   |

## 进程

进程给应用程序的关键抽象：

1. 一个独立的逻辑控制流，他提供一个假象，好像我们的程序独占地使用处理器
2. 一个私有的地址空间，他提供一个假象，好像我们的程序独占地使用内存系统

### 逻辑控制流

逻辑控制流：PC值的序列，PC是程序计数器的值

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-27_23-00-29.png)

根据图示就可以看出来，系统现在有三个进程ABC，先运行A一会，然后再运行B到B结束。然后开始运行C，C运行了一会又回到A运行到A结束然后再取运行C

切换进程执行的时候，未执行完的进程是被暂时挂起的

### 并发流

并发流：一个逻辑流的执行在时间上与另一个流重叠，举个例子就是两个流X和Y，X运行的中途，即X已经开始还没有结束的时候，Y在这个时间内开始

并发：多个流并发地执行

多任务：一个进程和其它进程轮流运行，多任务也叫时间分片

时间片：一个进程执行它的控制流的一部分的每一时间段

并行流：两个并发流运行在不同的处理器或者计算机上

### 私有地址空间

即虚拟内存

### 用户模式和内核模式

通过模式位来提供内核级的权限，模式位是在某个控制寄存器中的

### 上下文切换

调度：进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程

调度器：执行调度

上下文切换机制的工作

1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程

图示如下

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-27_23-08-57.png)

周期性定时器中断机制：白话就是你运行的够久了该换别人了

## 系统调用错误处理

当Unix系统级函数遇到错误，通常会返回-1，并设置全局整数变量errno来表示什么出错了

## 进程控制

### 获取进程ID

getpid：返回调用进程的PID

getppid：返回父进程的PID

### 创建和终止进程

进程总是处于下面三种状态之一：

1. 运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度
2. 停止。进程的执行被挂起，且不会被调度。当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行
3. 终止。进程永远地停止了。终止有三个原因，收到一个信号，信号的默认行为是终止进程，从主程序返回，调用exit函数

exit(int status)：exit函数用status作为退出状态来终止进程

fork：父进程通过调用fork来创建一个新的运行的子进程

子进程会获得与父进程用户级别虚拟地址空间相同的一份副本（但是独立的）。子进程还获得与父进程任何打开文件描述符相同的副本，意思就是子进程可以读写父进程打开的文件。子进程的PID和父进程的PID不一样

fork它只被调用一次，缺会返回两次：一次是在调用进程中，一次是在新创建的子进程中。父进程中，fork返回子进程的PID，子进程中返回0，因为子进程的PID总是为0

示例代码

```
int main(){
	pid_t pid;
	int x = 1;
	
	pid = Fork();
	if(pid==0){
		printf("child : x=%d\n",++x);
		exit(0);
	}
	
	printf("parent : x=%d\n",--x);
	exit(0);
}
```

结果

```
parent : x=0
child  : x=2
```

- 调用一次，返回两次。fork函数被父进程调用一次，但是缺返回两次，一次是回到父进程，一次是返回到新创建的子进程
- 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行他们的逻辑控制流中的指令
- 相同但是独立的地址空间。意思就是两个进程的地址空间内容等是相同的但是互不影响是独立的
- 共享文件，即父进程打开的文件，子进程可以对它进行读写

### 回收子进程

一个进程由于某种原因终止时，内核不是立即把他清楚，而是保持在一种已终止的状态中，直到被它的父进程回收。

僵死进程：终止了但是没有被回收就是僵死进程

init进程：init进程的PID为1，系统启动时内核创建，它不会终止，是所有进程的祖先。如果出现僵死进程，内核会安排init去回收

waitpid函数：等待子进程终止或者停止，默认情况下（options=0），waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就终止了，那么waitpid就立即返回。两种情况，waitpid返回的都是导致waitpid返回的已终止子进程的PID

pid\_t waitpid(pid\_t pid, int *statusp, int options);

1. 判定等待集合的成员

   等待集合的成员是由参数pid来确定的：

   如果pid>0，那么等待集合就是一个单独的子进程，它的进程ID等于pid

   如果pid=-1，那么等待集合就是由父进程所有的子进程组成的

2. 修改默认行为

   可以通过将options设置为常量WNOHANG、WUNTRACED和WCONTINUED的各种组合来修改默认行为

   - WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0）。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用

   - WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或停止子进程的PID。默认的行为是返回已终止的子进程。

   - WCONTINUED：挂机调用进程的执行，直到等待集合中一个运行的进程终止或等待集合中的一个被停止的进程收到SIGCONT信号重新开始执行

   - 也可以把这些options通过了或运算组合，比如WNOHANG|WUNTRACED：立即返回，如果等待集合中的子进程都没有被停职或终止，则返回0，如果有一个停止或终止，则返回该子进程的PID

3. 检查已回收的子进程的退出状态

   如果statusp参数是非空的，那么waitpid就会在status中放上关于导致返回到子进程的状态信息，status是statusp指向的值

   - WIFEXITED：如果子进程通过调用exit或者一个返回正常终止，就返回真
   - WEXITSTATUS：返回一个正常终止的子进程的退出状态。只有在WIFEXITED()返回为真时，才会定义这个状态
   - WIFSIGNALED：如果子进程时因为一个未被捕获的信号终止的，那么就返回真
   - WTERMSIG：返回导致子进程终止的信号的编号。只有在WIFSIGNALED()返回为真时，才定义这个状态
   - WIFSTOPPED：如果引起返回的子进程当前是停止的，那么就返回真
   - WSTOPSIG：返回引起子进程停止的信号的编号。只有在WIFSTOPPED()返回为真时，才定义这个状态
   - WIFCONTINUED：如果子进程收到SIGCONT信号重新启动，则返回真

4. 错误条件

   如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTER

5. wait

   wait函数是waitpid函数的简单版本

   pid_t wait(int *statusp)

   调用wait(&status)等价于调用waitpid(-1,&status,0)

6. 使用waitpid的示例

   ```
   #define N 2
   
   int main(){
   	int status, i;
   	pid_t pid;
   	
   	for(i=0;i<N;i++)
   		if((pid=Fork())==0)
   			exit(100+i);
   	
   	while((pid=waitpid(-1,&status,0))>0){
   		if(WIFEXITED(status))
   			printf("child %d termindated normallot with exit status=%d\n",
   					pidmWEXISTATUS(status));
   		else
   			printf("child %d terminated abnormally\n",pid);
   	}
   	
   	if(errno != ECHILD)
   		unix_error("waitpid error");
   	
   	exit(0);
   }
   ```

   结果

   ```
   child 22966 terminated normallt with exit status=100
   child 22967 terminated normallt with exit status=101
   ```

   注意，程序不会按照特定的顺序回收子进程，子进程回收的顺序是这台特定的计算机系统的属性，这种属于非确定性行为。针对这段代码想要消除这个非确定性，就是使用一个PID数组来按顺序存储子进程的pid，然后按顺序执行waitpid函数

### 让进程休眠

sleep函数将一个进程挂机一段指定的时间

sleep(unsigned int secs)

如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为sleep函数被一个信号中断而过早地返回。

pause(void)；

pause让调用函数休眠，直到该进程收到一个信号

### 加载并运行程序

execve函数

execve(const char *filename, const char *argv[], const char *envp[])

filename为可执行目标文件名字，argv[0]存储可执行目标文件的名字，argv[0]之后存的就是参数，envp存的是环境变量，函数执行成功时没有返回值，执行失败时的返回值为-1。

如图所示

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_00-05-10.png)

main开始执行，用户栈的组织结构,如图所示

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_00-05-50.png)

### 利用fork和execve运行程序

shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序

示例代码

```
#define MAXARGS 128

void eval(char *cmdline);
int parseline(char *buf, char **agrv);
int builtin_command(char **argv);

int main(){
	char cmdline[MAXLINE];
	
	while(1){
		printf("> ");
		Fgets(cmdline,MAXLINE,stdin);
		if(feof(stdin))
			exit(0);
		
		eval(cmdline);
	}
}
```

```
void eval(char *cmdline){
	char *argv[MAXARGS];
	char buf[MAXLINE];
	int bg;
	pid_t pid;
	
	strcpy(buf,cmdline);
	bg=parseline(buf,argv);
	if(argv[0]==NULL)
		return;
	
	if(!builtin_command(agrv)){
		if((pid=Fork())==0){
			if(execve(argv[0],argv,environ)<0){
				printf("%s: Command not found.\n",argv[0]);
				exit(0);
			}
		}
		
		if(!bg){
			int status;
			if(waitpid(pid,&status,0)<0)
				unix_error("waitfg: waitpid error");
		}
		else
			printf("%d %s",pid,cmdline);
	}
	return;
}

int builtin_command(char **argv){
	if(!strcmp(agrv[0],"quit"))
		exit(0);
	if(!strcmp(agrv[0],"&"))
		return 1;
	return 0;
}
```

```
int parseline(char *buf, char **argv){
	char *delim;
	int argc;
	int bg;
	
	buf[strlen(buf)-1]=' ';
	while(*buf && (*buf==' '))		//这一步是假如命令是空格开头的，就让buf指向空格之后的第一个非空元素，自己在Ubuntu上试了以下，发现ls命令前面加空格也可以执行，没有什么区别
		buf++;
		
	argc=0;
	while((delim=strchr(buf,' '))){
		argv[argc++]=buf;
		*delim='\0';
		buf=delim+1;
		while(*buf && (*buf==' '))
			buf++;
	}
	argv[argc] = NULL;
	
	if(argc == 0)
		return 1;
	
	if((bg=(*argv[argc-1]=='&'))!=0)
		argv[--argc]=NULL;
	
	return bg;
}
```

程序首先要堆输入的命令行进行解析，调用的是parseline函数，解析的是按空格分隔的命令行参数，然后最后构造好的命令会传给argv数组，如果第一个参数是内置的shell命令名，就会直接解释这个命令，如果是一个可执行目标文件，就会切换上下文来运行这个文件

如果最后一个参数是一个'&'字符，那么parseline返回1，表示应该在后台执行该程序（shell不会等他它完成），否则返回0，表示应该在前台执行这个程序（shell会等待他完成）

builtin_commd函数，用来检查第一个命令行参数是不是内置的shell，如果是就立即解释这个命令返回1，否则返回0.如果builtin_commd函数返回0，那么shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则shell使用waitpid函数等待作业终止。当作业终止时，shell就开始下一轮迭代。

这个shell没有设置回收他的后台子进程

## 信号

linux信号表

| 序号 | 名称      | 默认行为              | 相应事件                       |
| ---- | --------- | --------------------- | ------------------------------ |
| 1    | SIGHUP    | 终止                  | 终端线挂断                     |
| 2    | SIGINT    | 终止                  | 来自键盘的中断                 |
| 3    | SIGQUIT   | 终止                  | 来自键盘的退出                 |
| 4    | SIGILL    | 终止                  | 非法指令                       |
| 5    | SIGTRAP   | 终止并转储内存        | 跟踪陷阱                       |
| 6    | SIGABRT   | 终止并转储内存        | 来自abort函数的终止信号        |
| 7    | SIGBUS    | 终止                  | 总线错误                       |
| 8    | SIGFPE    | 终止并转储内存        | 浮点异常                       |
| 9    | SIGKILL   | 终止                  | 杀死程序                       |
| 10   | SIGUSR1   | 终止                  | 用户定义的信号1                |
| 11   | SIGSEGV   | 终止并转储内存        | 无效的内存引用（段故障）       |
| 12   | SIGUSR2   | 终止                  | 用户定义的信号2                |
| 13   | SIGPIPE   | 终止                  | 向一个没有读用户的管道做写操作 |
| 14   | SIGALRM   | 终止                  | 来自alarm函数的定时器信号      |
| 15   | SIGTERM   | 终止                  | 软件终止信号                   |
| 16   | SIGSTKFLT | 终止                  | 协处理器上的栈故障             |
| 17   | SIGCHLD   | 忽略                  | 一个子进程停止或者终止         |
| 18   | SIGCONT   | 忽略                  | 继续进程如果该进程停止         |
| 19   | SIGSTOP   | 停止直到下一个SIGCONT | 不是来自中断的停止信号         |
| 20   | SIGTSTP   | 停止直到下一个SIGCONT | 来自中断的停止信号             |
| 21   | SIGTTIN   | 停止直到下一个SIGCONT | 后台进程从终端读               |
| 22   | SIGTTOU   | 停止直到下一个SIGCONT | 后台进程向终端写               |
| 23   | SIGURG    | 忽略                  | 套接字上的紧急情况             |
| 24   | SIGXCPU   | 终止                  | CPU时间限制超出                |
| 25   | SIGXFSZ   | 终止                  | 文件大小限制超出               |
| 26   | SIGVTALRM | 终止                  | 虚拟定时器期满                 |
| 27   | SIGPROF   | 终止                  | 剖析定时器期满                 |
| 28   | SIGWINCH  | 忽略                  | 窗口大小变化                   |
| 29   | SIGIO     | 终止                  | 在某个描述符上可执行I/O操作    |
| 30   | SIGPWR    | 终止                  | 电源故障                       |

### 信号术语

**发送信号：**内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：1）内核检测到一个系统时间，比如除零错误或者子进程终止。2）一个进程调用了kill函数，显示地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己

**接受信号：**当目的进程被内核强迫以某种方式堆信号的发送做出反应时，他就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号

如图所示

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_10-49-21.png)

**待处理信号：**发出而没有被接收的信号

**在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；他们只是被简单地丢弃。一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。**

**一个待处理信号最多只能被接受一次。内核为每个进程在pending位向量中维护者待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，内核就会设置pending中的k位，而只要接受了一个类型位k的信号，内核就会清楚pending中的第k位。**

### 发送信号

**进程组**

getpgrp(void)：返回当前进程的进程组ID，一个子进程和它的父进程同属于一个进程组。

setpgid(pid\_t pid, pid\_t pgid)：改变自己或者其它进程的进程组,将进程pid的进程组改成pgid。如果pid为0，那么就使用当前进程的PID。如果pgid是0，那么就用pid指定的进程的PID作为进程组ID。如果进程15213是调用进程，那么setpgid(0,0)会创建一个新的进程组，其进程组ID是15213，并且把进程15213加入到这个新的进程组中。

**用/bin/kill程序发送信号**

kill -9 PID，终止一个进程

**从键盘发送信号**

作业：表示为对一条命令行求值而创建的进程

在任何时刻，至多只有一个前台作业和0个或多个后台作业。比如命令 ls | sort，这条命令会创建一个由两个进程组成的前台作业，这两个进程是通过Unix管道连接起来的：一个进程运行ls程序，另一个运行sort程序。shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。比如下图中展示了一个前台作业和两个后台作业的shell。前台作业终端父进程PID为20，进程组ID也为20。父进程创建两个子进程，每个也都是进程组20的成员

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_11-08-51.png)

键盘上输入Ctrk+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程，默认情况下，结果是终止前台作业。类似地，输入Ctrl+Z会发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。

**用kill函数发送信号**

kill(pid\_t pid, int sig)：如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid|（pid的绝对值）中的每个进程

**用alarm函数发送信号**

alarm(unsigned int secs)：安排内核在secs秒后发送一个SIGALRM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟。在任何情况下，对alarm的调用都将取消任何处理的闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数（如果这次对alarm的调用没有取消它的话）；如果没有任何待处理的闹钟，就返回零。

### 接受信号

当内核把进程p从内核模式切换到用户模式时，它久开始检查进程p的为被阻塞的待处理信号的集合。如果这个集合为空，那么内核将控制传递到p的逻辑控制流终端下一条指令，要是不为空，内核久选择集合中的某个信号k（通常是最小的k）并且强制p接受信号k。收到这个信号就会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递会p的逻辑控制流中的下一条指令。每个信号类型都有一个预定义的默认行为，是下面中的一种

- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）直到被SIGCONT信号重启
- 进程忽略该信号

signal(int signum,sighandler\_t handler)：修改和信号相关联的默认行为，如果成功返回指向但钱处理程序的指针，如出错则为SIG_ERR（不设置errno）

- 如果handler是SIG\_IGN,那么忽略类型为signum的信号。
- 如果handler是SIG_DFL,那么类型为signum的信号行为恢复为默认行为。
- 否则，handler就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这个叫做设置信号处理程序。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号

一个处理函数可以捕获不同类型的信号

示例程序1

```
void z(int sig){
	printf("Caught SIGINT\n");
	exit(0);
}

int main(){
	if(signal(SIGINT,sigint_handler)==SIG_ERR)
		unix_error("signal error");
		
	pause();
	return 0;
}
```

这个程序捕获ctrl+c发送的SIGINT信号，然后调用自定义的信号处理程序sigint\_handler然后输出一条语句就退出了

信号处理程序可以被其它信号处理程序中断,如下图所示

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_11-42-23.png)

### 阻塞和接触信号

**隐式阻塞机制：**内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。如上图中程序捕获了信号s，当前正在运行处理程序S。如果发送给该进程另一个信号s，那么直到处理程序S返回，s会变成待处理而没有被接收。

**显式阻塞机制：**应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号

sigprocmask(int how, const sigset\_t *set, sigset\_t *oldset)

sigprocmask函数改变当前阻塞的信号集合。具体的行为依赖于how的值

SIG\_BLOCK：把set中的信号添加到blocked中（blocked=blocked|set）

SIG\_UNBLOCK：从blocked中删除set中的信号（blocked=blocked&~set）

SIG\_SETMASK：block=set

如果oldset为空，那么blocked位向量之前的值保存在oldset中。

sigemptyset(sigset\_t *set)：初始化set为空集合

sigfillset(sigset\_t *set)：把每个信号都添加到set中

sigaddset(sigset\_t *set，int signum)：把sigum添加到set

sigdelset(sigset\_t *set，int signum)：从set中删除signum

sigismember(const sigset\_t *set, int signum)：如果signum是set的成员，那么sigismember返回1，否则返回0

示例代码

```
sigset_t mask,prev_mask;

Sigemptyset(&mask);
Sigaddset(&mask,SIGINT);

Sigprocmask(SIG_BLOCK,&mask,&prev_mask);
Sigprocmask(SIG_SETMASK,&prev_mask,NULL);
```

### 编写信号处理程序

1. 安全的信号处理

   - G0.**处理程序要尽可能简单**。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接受信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志。

   - G1.**处理程序中只调用异步信号安全的函数**。异步信号安全的函数要么是可重入的（例如只访问局部变量），要么不能被信号处理程序中断

     异步信号安全的函数举例

     ![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_18-34-51.png)

   - G2.**保护和恢复errno**。许多linux异步信号安全的函数都会在出错返回时设置errno。在处理程序中调用这样的函数可能会干扰主程序中其它依赖于errno的部分。解决办法是在进入处理程序时把errno保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回才有此必要。如果处理程序调用\_exit终止该进程，那么久不需要这样做了。

   - G3.**阻塞所有的信号，保护对全局共享数据结构的访问**。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问（读或着写）该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因时从主程序访问一个数据结构d通常需要一系列的指令，如果指令序列被访问d的处理程序被中断，那么处理程序可能会发现d的状态不一致，得到不可预知的结果。在访问d时暂时阻塞信号保证了处理程序不会中断该指令序列

   - G4.**用volatile声明全局变量**。考虑一个处理程序和一个main函数，他们共享一个全局变量g。处理程序更新g，main周期性地读g。对于一个优化编译器而言，main中g的值看上去从来没有变化过，因此使用缓存在寄存器中g的副本来满足对g的每次引用是很安全的。如果这样，main函数可能永远都无法看到处理程序更新过的值。可以用volatile类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：

     volatile int g；

     volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值。一般来说，和其它所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。

   - G5.**用sig\_atomic\_t声明标志**。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C提供一种整形数据节后sig\_atomic\_t，对他的读和写保证会是原子的（不可中断的），因为可以用一条指令来实现他们：

     volatile sig\_atomic\_t flag；

     因为他们是不可中断的，所以可以安全地读和写sig\_atomic\_t变量，而不需要暂时阻塞信号。注意，这里对原子性的保证只适用于单个的读和写，不适用于向flag++或flag=flag+10这样的更新，他们可能需要多条指令。

   要记住我们这里讲述的规则是保守的，也就是说他们不总是严格必须的。例如，如果你知道处理程序绝对不会修改errno，那么久不需要保存和恢复errno。或者如果你可以证明printf的实例都不会被处理程序中断，那么在处理程序中调用printf就是安全的。对共享全局数据结构的访问也是同样。不过，一般来说这种断言很难证明。所以我们建议你采用保守的方法，遵循这些规则，使得处理程序尽可能简单，调用安全函数，保存和恢复errno，保护对共享数据结构的访问，并使用volatile和sig\_atomic\_t 。

2. 正确的信号处理

   **信号的一个与直接不符的方面是未处理的信号是不排队的。**pending位向量中一种类型的信号对应一位，所以每种类型最多只能有一个未处理的信号。如果两个类型k的信号发送给一个目的进程，但是当前进程正在执行信号k的处理程序，信号k被阻塞了，第二个信号就被简单地丢弃了；他不会排队。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了

   实例程序

   ![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_19-08-00.png)

   这段代码中创建的第三个进程不会被回收，原始因为，父进程接受捕获了第一个信号。当处理程序还在处理第一个信号时，第二个信号就传送并添加到了待处理信号集合里。然而，因为SIGCHLD信号被SIGCHLD处理程序阻塞了，所以i第二个信号就不会被接受。此后不久，就在处理程序还在处理第一个信号时，第三个信号到达了。因为已经有一个SGICHLD，第三个SIGCHLD信号会被丢弃。一段时间之后，处理程序返回，内核注意到有一个待处理的SIGCHLD信号，就迫使父进程接受这个信号。父进程捕获这个信号，并第二次执行处理程序。在处理程序完成第二个信号的处理之后，已经没有待处理的SIGCHLD信号了，而且也绝对不会再有，因为第三个SIGCHLD的所有信息都已经丢失了。

   改进版本

   ![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_19-57-20.png)

3. 可移指的信号处理

   sigaction(int signum, struct sigaction *act, struct sigaction *oldact)函数：它要求用户设置一个复杂结构的条目。

   Signal简介的方式，他的作用是调用Signal,Signal包装函数设置了一个信号处理程序，其信号处理语义如下：

   - 只有这个处理程序当前正在处理的哪种类型的信号被阻塞。
   - 和所有信号实现一样，信号不会排队等待
   - 只要可能被中断的系统调用会自动重启
   - 一旦设置了信号处理程序，他就会移指保持，直到Signal带着handler参数为SIG\_IGN或者SIG\_DFL被调用

### 同步流以避免讨厌的并发错误

解决竞争的方法：

在调用fork之前，阻塞SIGCHLD信号，然后在子进程的第一行语句中添加接触阻塞的SUFCHLD信号的语句，这样做的原因是因为子进程会复制父进程的被阻塞集合。

### 显式地等待信号

sigsuspend(const sigset\_t *mask)：暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果他的行为是终止，那么该进程不从sigsuspend返回就终止。如果他的行为是运行一个处理程序，那么sigsuspend从处理程序返回，恢复调用sigsuspend时原有的阻塞集合

## 非本地跳转

非本地跳转：他将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。

实现非本地跳转的函数setjmp和longjmp

setjmp(jmp\_buf env)：在env缓冲区中保存当前调用环境，以供后面的longjmp使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器。setjmp返回的值不能被赋值给变量，不过可以安全地用在switch或条件语句的测试中

sigsetjmp(sigjmp\_buf env, int savesigs);

longjmp(jmp\_buf env， int retval)：在env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。

siglongjmp(sigjmp\_buf env, int retval);

作用：

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-07-28_20-40-19.png)