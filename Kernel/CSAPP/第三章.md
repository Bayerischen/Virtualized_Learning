# 程序的机器级表示

## 一、基础

**1.汇编语言主要由一下3类指令组成**

1)汇编指令：机器码的助记符，有对应的机器码

2)伪指令：没有对应的机器码，由编译器执行，计算机并不执行

3)其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码

**2.存储器**

一个存储器有128个存储单元，从0开始编号，即为0~127，计算机中1bit即为一个二进制位，8 bit位一个字节（1 byte=8 bit)

一个存储单元可以存储一个字节

所以一个存储器既有1024 bit(128 byte)

1B=8bit 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB

B表示byte

**3.CPU对存储器的读写**

CPU要想进行数据的读写，必须和外部器件进行3类消息的交互

1)存储单元的地址(地址信息)

2)器件的选择，读或写的命令(控制信息)

3)读或写的数据(数据信息)



**4.总线就是CPU将信息传到芯片的导线**

总线逻辑上分3种：1)地址总线

​								 2)控制总线

​								 3)数据总线

CPU对存储器读写过程

1)CPU通过地址线将地址信息3发出

2)CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据

3)存储器将3号单元中的数据8通过数据线送入CPU

一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元

下图为具有10根地址线的CPU向内存发出地址信息11时10跟地址线上传送的二进制信息

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/497b84c4184f92d8.png?x-oss-process=style/resery)

8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16但是这两个CPU向内存中写入数据89D8H时都不一样的.

控制总线时一些不同控制线的集合，有多少根控制总线，就意味着1CPU提供了对外部器件的多少种控制

内存读或写命令是由几根控制休闲综合发出的，其中由一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向控制线上输出低电平表示将要读写数据；有一根称为“写信号输出”的控制线则负责传送写信号

**各类存储器芯片**

随机存储器（RAM随机存储器）

住随机存储器一般由两个位置上的RAM组成，装在主板上RAM和插在扩展插槽上的RAM

装有BIOS的ROM（ROM只读存储器）

BIOS是由主板和各类接口卡厂商提供的软件系统可以通过它利用该硬件设备进行最基本的输入输出，在主板和某些接口卡上插有存储相应的BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS；显卡上的ROM存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-05_21-51-18.png)

上述的那些存储器，在物理上是独立的器件，但有两点相同之处

1）都和CPU的总线相连

2）CPU对它们进行读或写的时候都通过控制线发出内存读写命令

所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间

## 二、寄存器

**寄存器**

一个典型的CPU有运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。总线相对于CPU内部来说是外部总线，内部总线实现CPU内部各个器件之间的联系。
简而言之，CPU中：
1）运算器进行信息处理
2）寄存器进行信息存储
3）控制器控制各种器件进行工作
4）内部总线连接各种器件，在他们之间进行数据的传送

8086CPU的寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器
以AX为例，寄存器的逻辑结构如图所示（BX、CX、DX也是如此）
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-28-36.png)

8086CPU的上一代CPU中的寄存器都足8位的，为了保证兼容，使原来基于上代 CPU编3的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4 个寄存器都可分为两个可独立使用的8位寄存器来用：
1）AX可分为AH和AL
2）BX可分为BH和BL
3）CX可分为CH和CL
4）DX可分为DH和DL
以AX为例，8086CPU的丨6位寄存器分为两个8位寄存器的情况如图所示
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-32-43.png)
AX的低8位(0位〜7位)构成了 AL寄存器，高8位(8位〜15位)构成了 AH寄存器。 AH和AL寄存器是可以独立使用的8位寄存器。图2.4展示了 16位寄存器及它所分成的 两个8位寄存器的数据存储的情况
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-33-31.png)

字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。
字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和地位字节。

接下来看一下CPU执行表（下表）中所列的程序段中的每条侑令后，对寄存器中的数据 进行的改变。
下表程序段中指令的执行情况之一(原AX中的值：0000H,原BX中的值：0000H)
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-36-37.png)
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-36-50.png)
指令执行后AX中的数据为多少？思考后看分析。
分析：
程序段中的最后条指令add ax,bx,在执行前ax和bx中的数据都为8226H比相加后所得的值为：1044CH，但是ax为16位寄存器，只能存放4位十六进制的数据，所以最 高位的1不能在ax中保存，ax种的数据为：044CH。

程序段种指令的执行情况之二
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_10-39-22.png)
指令执行后AX中的数据为多少？思考后看分析。
分析：
程序段中的最后一条指令add al,93H,在执行前，al中的数据为C5H，相加后所得的 值为：158H，但是al为8位寄存器，只能存放两位十六进制的数据，所以最高位的1丢失，ax中的数据为：0058H。（这里的丢失，指的是进位值不能在8位寄存器中保存，但 是CPU并不真的丢弃这个译位值，关于这个问题，我们将在后面的课程中讨论。）
注:此时al是作为一个独立的8位寄存器来使用的，和ah没有关系，CPU在执行 这条指令时认为ah和al是两个不相关的寄存器。不要错误地认为，诸如add al,93H的指 令产生的进位会存储在ah中，add al,93H进行的是8位运算。
如采执行add ax,3H.低8位的进位会存储在ah种，CPU在执行这条指令时认为只有一个16位寄存器ax,进行的是16位运算。指令add ax,93H执行后，ax中的值为:0158H。此时，使用的寄存器是16位寄存器ax, add ax,93H相当于将ax中的16位数据00C5H和另一个16位数据0093H相加，结果是16位的0158H。

**例举一些错误指令**

mov ax,bl 	(在8位寄存器和16位寄存器之间传送数据〉
mov bh,ax 	(在16位寄存器和8位寄存器之间传送数据）
mov al,20000 	(8位寄存器最大可存放值为255的数据）
add al,100H	（将一个高于8位的数据加到一个8位寄存器中）
以上都是错误的指令，错误的原因都是指令的两个操作对象的位数不一致。

**16位结构的CPU**

概括地讲，16位结构(16位机、字长为16位等常见说法，与16位结构的含义相同) 描述了一个CPU具有下面几方面的结构特性。
1）运算器一次最多可以处理16位的数据
2）寄存器的最大宽度为16位
3）寄存器和运算器之间的通路为16位
8086是16位结构的CPU,这也就是说，在8086内部，能够一次性处理、传输、暂 时存储的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU 中处理、传输、暂时存放，对于16位CPU,能一次性处理、传输、暂时存储16位的地址。

**8086CPU给出物理地址的方法**

8086CPU采用一种在内部用两个16位地址合成的放法来形成一个20位的物理地址
8086CPU相关部件的逻辑结构如图所示
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_18-46-20.png)

图解当8086CPU要读写内存时：
(1)	CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址;
(2)	段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；
(3)	地址加法器将两个16位地址合成为一个20位的物理地址；
(4)	地址加法器通过内部总线将20位物理地址送入输入输出控制电路；
(5)	输入输出控制电路将20位物理地址送上地址总线；
(6)	20位物理地址被地址总线传送到存储器。

地址加法器采用物理地址=段地址X16+偏移地址的方法用段地址和偏移地址合成物理 地址。例如，8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图所示
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_18-47-55.png)

“段地址X16”有一个更为常用的说法是左移4位。计算机中的所有信息都是以二进制的形式存储 的，段地址当然也不例外。机器只能处理二进制信息，“左移4位”中的位，指的是二进制位。
规律：一个数据的十六进制形式左移1位，相当于乘以16: —个数据的十进制 形式左移1位，相当于乘以10; T*个X进制的数据左移1位，相当于乘d以X。

**“段地址X16+偏移地址=物理地址”的本质含义**

“段地址X16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础 地址(段地址X16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。
更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模 式的一种具体实现方案。8086CPU中，段地址X16可看作是基础地址。

**段寄存器**

8086CPU有4个段寄存器：CS、DS、SS、ES。当 8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。

**CS和IP**

CS为代码段寄存器，IP为指令指针寄存器
CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成的指令的物理地址
CPU将CS:IP指向的内容当作指令执行
8086CPU的工作过程可以简要描述如下
1）从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器 IP=IP+所读取指令的长度，从而指向下一条指令；
2）执行指令。
3）转到步骤(1), 重复这个过程。
在8086CPU加电启动或复位后（即CPU刚开始工作时)CS和IP被设H为 CS=FFFFH, IP=OOOOH,即在8086PC机刚；3动时，CPU从内存FFFFOH单元中读取指令 执行，FFFFOH单元中的指令是8086PC机开机后执行的第一条指令。
8086CPU提供的转移指令修改CS、IP的内容
1）jmp段地址：偏移地址：用指令中给出的段地址修改CS,偏移地 址修改IP。
例子
jmp2AE3:3,执行后：CS=2AE3H, 1P=0003H, CPU 将从 2AE33H 处读取指令。
2）jmp某一合法寄存器，寄存器中的值修改IP。（修改IP的值）
例子
jmp ax,
指令执行前：ax=1000H, CS=2000H,IP=0003H
指令执行后：ax=1000H, CS=2000H,IP=1000H

## 三、寄存器（内存访问）

**内存中字的存储**
CPU中，用16位寄存器来存储一个字。高8位存放高位字 节，低8位存放低位字节。
我们将起始地址为N的字单元简称为N地址字单元。比如一个字 单元由2、3两个内存单元组成，则这个字单元的起始地址为2,我们可以说这是2地址字单元。

**DS和【address】**
DS寄存器：通常用来存放要访问数据的段地址
[address]表示一个偏移地址位address的内存单元，段地址默认放在DS中。通过数据段 段地址即可定位内存单元
mov bx, 1000H ;8086CPU不支持将数据直接送入段寄存器的操作

mov ds, bx ;ds存放数据段地址

mov [0], al ;将al数据（1字节）存到1000H段的0偏移地址处10000H

mov ax, [2] ;将数据段偏移地址2处的一个字（2字节）存放到ax寄存器

add cx, [4] ;将偏移地址4处的一个字数据加上cx寄存器数据放到cx寄存器

sub dx, [6] ;dx寄存器数据减去数据段偏移地址6处的字数据存到dx

注：8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以 mov ds,1000H这条指令是非法的。

**字的传送**
因为8086CPU是 16位结构，有16根数据线，所以，可以一次性传送丨6位的数据，也就是说可以一次性 传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。

**mov指令**

mov  寄存器，数据		     比如：mov  ax，8 
mov  寄存器，寄存器 	     比如：mov  ax，bx 
mov  寄存器，内存单元         比如：mov  ax，[0] 
mov  内存单元，寄存器         比如：mov  [0]，ax 
mov  段寄存器，寄存器         比如：mov  ds，ax
mov  寄存器，段寄存器         比如：mov  ax，ds
mov  内存单元，寄存器         比如：mov  ax,1000H mov  ds,ax mov  [0],cs
mov  段寄存器，内存单元     比如：mov ax,1000H mov ds,ax mov ds,[0]

**add指令**

add指令有以下几种形式
add  寄存器，数据            比如：add ax，8 
add  寄存器，寄存器        比如：addax，bx
add  寄存器，内存单元    比如：addax，[0] 
add  内存单兀，寄存器    比如：add[0]，ax

**sub指令**

sub指令有以下几种形式
sub  寄存器，数据            比如：sub ax,9 
sub  寄存器，寄存器        比如：sub ax,bx 
sub  寄存器，内存单元    比如：sub ax,[0] 
sub  内存单元，寄存器    比如：sub[0]，ax

注：add和sub指令不能对段寄存器进行操作，换句话来说就是算数运算指令不能对段寄存器进行操作

**CPU提供的栈机制**

8086CPU提供入栈和出栈指令，最基本的两个是PUSH(入栈）和POP(出栈)。比 如，push ax表示将寄存器ax中的数据送入栈中，pop ax表示从栈顶取出数据送入ax。
8086CPU的入栈和出栈操作都是以字为单位进行的。

下面举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_20-12-20.png)

**SS和SP**

8086CPU中，有两个寄存器，段寄存器SS和寄存器SP,栈顶的段地址存放 在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指 令执行时，CPU从SS和SP中得到栈顶的地址。

8086CPU中，入栈时，栈顶从高地fat向低地fat方向増长。

push ax表示将寄存器ax中的数据送入栈中，由两步完成。
1.SP=SP-2, SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
2.将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

下图描述了 8086CPU对push指令的执行过程
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_20-15-41.png)
换一个角度看，任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素， 也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地 址为桟S底部的字单元的偏移地址+2,栈最底部字单元的地址为1000:000E,所以栈空 时，SP=0010H。

pop ax表示从栈丽出数据送入ax,由以下两步完成。 
1.将SS:SP指向的内存单元处的数据送入ax中；

2. SP=SP+2, SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

push和pop指令的格式可以是如下形式：
push  寄存器			 将一个寄存器中的数据入栈 
pop    寄存器  		      出栈，用一个寄存器接收出栈的数据
push  段寄存器  		  将一个段寄存器中的数据入栈
pop    段寄存器  		    出栈，用一个段寄存器接收出栈的数据
push  内存单元  		  将一个内存字单元处的字入栈（注意：栈操作都是以字为单位〉
pop    内存单元  		    出栈，用一个内存字单元接收出找的数据

## 四、汇编程序从写出到执行的过程

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_20-30-23.png)
加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）
下面就是一段简单的汇编语言源程序

```
assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。

codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始
			   ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址

	mov ax, 0123H
	mov bx, 0456H 
	add ax, bx
	add ax, ax 
	
	mov ax, 4c00H 
	int 21H ;这两条指令实现程序的返回
	
codesg ends ;名称为“codesg”的段到此结束

end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译
```

与结束相关的概念
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_20-33-08.png)

DOS系统中.exe文件中的程序的加载过程
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2019-12-06_20-37-25.png)
注：在DOS中运行程序时，是command将程序加载入内存，所以程序运 行结束后返回到command中，而在这里是Debug将程序加载入内存，所以程序运行结束 后要返回到Debug中。

程序的加载顺序时：
command加载Debug，Debug加载l.exe。返回的顺序是：从l.exe中的程序返回到 Debug，从 Debug 返回到 command。

## 五、[BX]和LOOP

注：（为了方便此章往后我们定义（ax）表示ax中的内容，idata表示常量例如[idata]，就表示[1],[2],[3]……）

**[bx]**

bx中存放的数据作为一个偏移地址EA，段地址SA默认储存在DS中，将SA:EA处的数据送入ax中。即：（ax）=（（ds）*16+（bx））

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-01-30_13-52-16.png)

思考后看分析

注意，inc bx的含义是bx中的内容加1,比如下面两条指令:

mov bx,1

inc bx

执行后，bx=2

**分析**

(1)先看一下程序的前3条指令:

mov ax,2000H 

mov ds,ax 

mov bx,1000H

这3条指令执行后，ds=2000H, bx=1000H。

(2)	接下来，第4条指令：

mov ax,[bx]

指令执行前：ds=2000H，bx=1000H，则mov ax，[bx]将把内存2000:1000处的字型数据送入ax中。该指令执行

后，ax=00beH。

(3)	接下来，第5、6条指令：

inc bx inc bx

这两条指令执行前bx=1000H，执行后bx=1002H。

(4)	接下来，第7条指令：

mov [bx]/ax

指令执行前：ds=2000H，bx=1002H，则mov [bx]，ax将把ax中的数据送入内存 2000:1002处。指令执行后，

2000:1002单元的内容为BE，2000:1003单元的内容为00。

(5)	接下来，第8、9条指令：

inc bx 

inc bx

这两条指令执行前bx=1002H，执行后bx=1004H。

(6)	接下来，第10条指令：

mov [bx],ax

指令执行前：ds=2000H, bx=1004H,则mov [bx]，ax将把ax中的数据送入内存 2000:1004处。指令执行后，

2000:1004单元的内容为BE, 2000:1005单元的内容为00。

(7)接下来，第11条指令:

inc bx

这条指令执行前bx=1004H，执行后bx=1005H。

(8)接下来，第12条指令:

mov [bx],al

指令执行前：ds=2000H，bx=1005H，则mov [bx]，al将把al中的数据送入内存 2000:1005处。指令执行后，

2000:1005单元的内容为BE。

接下来，第13条指令:

inc bx

这条指令执行前bx=1005H，执行后bx=1006H。

(10)接下来，第14条指令：

mov [bx],al

指令执行前：ds=2000H，bx=1006H,则 mov [bx]，al 将把 al 中的数据送入内存2000:1006处。指令执行后，

2000:1006单元 的内容为BE。

程序执行后，内存中的情况如图5.2所示。

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-01-30_14-13-29.png)

**loop**

loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两步操作， 

①(cx)=(cx)-1;

②判断CX中的值，不为零则转至标号处执行程序，如果为零则向下执行。

cx和loop指令相配合实现循环功能的3个要点

1）在cx中存放循环次数

2）loop指令中的标号所标识地址要在前面

3）要循环执行的程序段，要写在标号和loop指令的中间框架如下：

  mov cx,循环次数

s:

  循环执行的程序段 

  loop s

**loop和[bx]的联合应用**

考虑这样一个问题，计算ffff:0〜ffff:b单元中的数据的和，结果存储在dx中。

(1)运算后的结果是否会超出dx所能存储的范围？

ffff:0〜ffff:b内存单元中的数据是字节型数据，范围在0-255之间，12个这样的数据相加，结果不会大于65535,可以在dx中存放下。

(2) 我们能否将ffff:0〜ffff:b中的数据直接累加到dx中？

当然不行，因为ffff:0〜ffff:b中的数据是8位的，不能直接加到16位寄存器dx中。

(3) 我们能否将ffff:0〜ffffib中的数据累加到dl中，并设置(dh)=0,从而实现累加到 dx中？

这也不行，因为dl是8位寄存器，能容纳的数据的范围在0-255之间，

中的数据也都是8位，如果仅向dl中累加12个8位数据，很有可能造成进位丢失。

(4)我们到底怎样将中的8位数据，累加到16位寄存器dx中？

从上面的分析中，可以看到，这里面有两个问题：类型的匹配和结果的不超界。具体的说，就是在做加法的时

候，我们有两种方法：

①（dx）=（dx）+内存中的8位数据；

②（dl）=（dl）+内存中的8位数据。

第一种方法中的问题是两个运算对象的类型不匹配，第二种方法中的问题是结果有可能超界。

怎样解决这两个看似矛盾的问题？目前的方法就是得用一个16位寄存器来做中
介。将内存单元中的8位数据赋值到一个16位寄存器ax 中，再将ax中的数据加到dx上，从而使两个运算对象的类

型匹配并且结果不会超界。

想清楚以上的问题之后，编写程序如下。

```汇编语言
assume cs:code 
code segment
	mov ax,0ffffh 
	mov ds,ax 
	mov bx,0			;初始化ds:bx指向ffff:0
	mov dx,0			;初始化累加寄存器dx，(dx)=0 
	mov cx,12			;初始化循环计数寄存器cx，(cx) =12
s:	mov al,[bx]
	mov ah,0 
	add dx,ax			;间接向dx中加上（（ds）*16+（bx）)单元的数值 
	inc bx 				;ds:bx指向下一个单元
	loop s
	mov ax,4c00h 
	int 21h
code ends 
end
```



**段前缀**

指令“mov ax，[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我 们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：

(1)mov ax,ds:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址在bx中，段地址在ds中。

(2)mov ax,cs:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址在bx中，段地址在cs中。

(3)mov ax,ss:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址在bx中，段地址在ss中。

(4)mov ax,es:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址在bx中，段地址在es中。

(5)mov ax,ss:[0]
将一个内存单元的内容送入ax,这个内存单元的长度为2字节(字单元存放一个 字，偏移地址为0,段地址在ss中。

(6) mov ax,cs:[0]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址为0,段地址在cs中。

**一段安全的空间**

在一般的PC机中，DOS方式下， DOS和其他合法的程序一般都不会使用0:200:2ff(00200h~002ffh)的256个字节的空间。 

**总结**

(1)我们需要直接向一段内存中写入内容；
(2)这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；
(3)DOS方式下，一般情况，0:200〜0:2ff空间中没有系统或其他程序的数据或 代码；
(4)以后，我们需要直接向一段内存中写入内容时，就使用0:200:2ff这段空间。

## 六、包含多个段的程序

程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在 执行的过程中向系统申请。我们暂时不讨论第二种方法。

我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。 我们通过在源程序中定义段来进行内存空间的获取。

## 七、更灵活的定位内存地址的方法

**大小写转换问题**

如遇见需要大小写转换的时候，使用

大写：and 某一寄存器，11011111B

小写：or    某一寄存器，00100000B

这个方法即可对大小写进行转化，而且省去了检测字符是大写和小写的代码。

**[bx+idata]**

之前我们用[bx]的方式来指明一个内存单元，还可以用一种更为灵活的方式来指 明内存单元：[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata(bx中的数值加上 idata)。

**用[bx+idata]的方式进行数组的处理**

程序可以写成几种形式

```
mov ax,datasg 
mov ds,ax
mov bx,0
mov cx,5 
s :	mov al, [bx]
    and al,11011111b 
    mov [bx],al 
    mov al,[5+bx] 
    or  al,00100000b 
    mov [5+bx],al 
    inc bx 
    loop s
```

```
mov ax,datasg 
mov ds,ax 
mov bx,0
mov cx,b 
mov al,0[bx] 
and al,11011111b 
mov 0[bx],al 
mov al,5[bx] 
or al,00100000b 
mov 5[bx],al 
inc bx 
loop s
```

**si和di**

si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。

用si和di实现将字符串'welcometo masm!’复制到它后面的数据区中。

```
assume cs::codesg,ds:datasg
datasg segment
 db ’welcome to masm'
 db ’................................'
datasg ends
```

**分析**

我们编写的程序大都是进行数据的处理，而数据在内存中存放，所以我们在处理数据 之前首先要搞清楚数据存储在什么地方，也就是说数据的内存地址。现在我们要对datasg 段中的数据进行复制，先来看一下要复制的数据在什么地方，dataSg:0,这是要进行复制 的数据的地址。那么复制到哪里去呢？它后面的数据区。“welcome to masm!”从偏移地 址0开始存放，长度为16个字节，所以，它后面的数据区的偏移地址为16,就是字符串
...”存放的空间。清楚了地址之后，我们就可以进行处理了。我们用ds:si指向要
复制的源始字符串，用ds:di指向复制的目的空间，然后用一个循环来完成复制。代码段如下。

(注:在程序中，用16位寄存器进行内存单元之间的数据传送，一次复制2个字 一共循环8次。)

```
codesg segment
start: mov ax,datasg 
	   mov ds,ax 
	   mov si,0 
	   mov cx,8 
    s: mov ax,0[si] 
       mov 16[si],ax 
       add si,2 
       loop s
	   mov ax,4c00h 
       int 21h
codesg ends 
end start
```

**[bx+si]和[bx+di]**

在前面，我们用[bx(si或di)]和[bx(si或di)+idata]的方式来指明一个内存单元，我们还 可以用更为灵活的方式：[bx+si]和[bx+di]。
[bx+si]和[bx+di]的含义相似，我们以[bx+si]为例进行讲解。
[bx+si]表示一个内存单元，它的偏移地址为(bx)+(siX即bx中的数值加上si中的数
值)。
指令mov ax，[bx+si]的含义如下：
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个 字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。
数学化的描述为：（ax)=((ds)*16+(bx>Ksi))
该指令也可以写成如下格式(常用)：

**不同的寻址方式的灵活应用**

(1)[idata]用一个常量来表示地址，可用于直接定位一个内存单元；
(2)[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；
(3)[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接 定位一个内存单元；
(4)[bx+si]用两个变量表示地址；
(5)[bx+si+idata]用两个变量和一个常量表示地址。

**寻址方式[bx(或 si、di)+idata]、[bx+si(或 di)]、[bx+si(或 di)+idata]的意义和应用；**
**二重循环问题的处理；**
**栈的应用；**
**大小写转化的方法；**
**and、or 指令。**

## 八、数据处理的两个基本问题

**bx、si、di和bp**

前三个寄存器我们已经使用过了，现在来总结一下

(1)在8086CPU中，只有这4个寄存器可以用在中来进行内存单元的寻址。

(2)在[...]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp 和 si、bp 和 di。

(3)只要在[...]中使用寄存器bp,而指令中没有显性地给出段地址，段地址就默认在 ss中。比如下面的指令。

mov ax,[bp]				含义：（ax）=（（ss）*16+（bp））

mov ax,[bp+idata]	 含义：（ax）=（（ss）*16+（bp）+idata）

mov ax,[bp+si]		   含义：（ax）=（（ss）*16+（bp）+（si））

mov ax,[bp+di]		   含义：（ax）=（（ss）*16+（bp）+（di））

**机器指令存储的数据在什么地方**

绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运 算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要 处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、 内存、端口(端口将在后面的课程中进行讨论)，比如表8.1中所列的指令。

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-01-31_15-23-03.png)

**汇编语言中数据位置的表达**

(1)立即数(idata)
对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称 为：立即数(idata),在汇编指令中直接给出。

⑵寄存器
指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。

(3)段地址(SA)和偏移地址(EA)
指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄 存器中。

**寻址方式总结**

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-01-31_15-30-25.png)

**指令要处理的数据有多长**

8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是

字节操作。对于这个问题，汇编语言中用以下方法处理。

1)通过寄存器名指明要处理的数据的尺寸。

2)在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编 指令中可以为word或byte。

例如

用word ptr指明了指令访问的内存单元是一个字单元。

用byte ptr指明了指令访问的内存单元是一个字节单元。

3)其他方法

有些指令默认了访问的是字单元还是字节单元，比如，push [1000H]就不用指明访问的是字单元还是字节单元，

因为push指令只进行字操作。

**寻址方式的综合应用**

8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组(字符串)。一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项， 用si定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如： [bx].idata、[bx].idata[si]。
在C语言程序中我们看到，如：dec.cpfi], dec是一个变量名，指明了结构体变量的 地址，cp是一个名称，指明了数据项cp的地址，而i用来定位cp中的每一个字符。汇编 语言中的做法是：bx_10h[si]。看一下，是不是很相似？

**总结：**

**访问结构体内的数据：[bx+idata+si]**

**定位整个结构体：[bx]**

**定位结构体中的某一个数据项：[bx+idata]**

**定位数组顶的每个元素：[si]**

### div指令

div是除法指令，使用div做除法的时候应注意以下问题。
(1)	除数：有8位和16位两种，在一个reg或内存单元中。
(2) 被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位， 默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存 放高16位，AX存放低16位。
(3) 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数； 如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。

**伪指令dd**

前面我们用db和dw定义字节型数据和字型数据。dd是用来定义dw〇rd(d〇ubIe word,双字)型数据的。

**dup**

dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的 符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。

dup的使用格式如下。

db重复的次数dup (重复的字节型数据)

dw重复的次数dup (重复的字型数据）

dd重复的次数dup (重复的双字型数据)

dup是一个十分有用的操作符，比如要定义一个容量为200个字节的栈段，如果不用 dup，则必须：

stack segment 

​	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

​	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

​	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

​	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

​	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

stack ends

当然，你可以用dd,使程序变得简短一些，但是如果要求定义一个容量为1000字节 或10000字节的呢？如果没有

dup，定义部分的程序就变得太长了，有了 dup就可以轻松 解决。如下：

stack segment 

​	db 200 dup (0) 

stack ends

## 九、转移指令的原理

可以修改IP,或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就
是可以控制CPU执行内存中某处代码的指令。
8086CPU的转移行为有以下几类。
•	只修改IP时，称为段内转移，比如：jmp ax。
•	同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。
由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。
•	短转移IP的修改范围为-128〜127。
•	近转移IP的修改范围为-32768〜32767。
8086CPU的转移指令分为以下几类。
•	无条件转移指令(如：jmp)
•	条件转移指令
•	循环指令(如：loop)
•	过程
•	中断

这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。我们在这一章 主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。

### 操作符offest

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地 址。比如下面的程序：

```
assume cs:codesg 
codesg segment 
	start:mov ax,offset start 			相当于mov ax,0
	    s: mov axfoffset s				相当于mov ax, 3
codesg ends 
end start
```

在上面的程序中，offset操作符取得了标号start和s的偏移地址0和3,所以指令： mov ax,offset start相当于指令mov ax,0，因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0;
mov ax,offset s相当于指令mov ax，3，因为s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3。

### jmp指令

jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。

jmp指令要给出两种信息：
(1)	转移的目的地址
(2)	转移的距离(段间转移、段内短转移，段内近转移）
不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。

### 依据位移进行转移的jmp指令

jmp short标号(转到标号处执行指令）
这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128〜127,也就是 说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。jmp指 令中的“short”符号，说明指令进行的是短转移。jmp指令中的“标号”是代码段中的标 号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。

实际上，`jmp short 标号` 的功能为: (IP)-(IP)+8位位移。
(1) 8位位移=标号处的地址-jmp指令后的第一个字节的地址;
(2) short指明此处的位移为8位位移;
(3) 8 位位移的范围为-128~127.用补码表示
(4) 8 位位移由编译程序在编译时算出。

还有一种和 `jmp short 标号` 功能相近的指令格式，`jmp near ptr 标号`，它实现的是段内近转移。
`jmp near ptr 标号` 的功能为: (IP)=(IP)+16位位移。

(1) 16位位移=标号处的地址-jmp指令后的第一个字节的地址;
(2) near ptr 指明此处的位移为16位位移，进行的是段内近转移;
(3) 16 位位移的范围为-32768~32767，用补码表示
(4) 16 位位移由编译程序在编译时算出。

### 转移的目的地址在指令中的jmp命令

前面讲的jmp指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前 IP的转移位移。
“jmp far ptr标号”实现的是段间转移，又称为远转移。功能如下:

(CS)=标号所在段的段地址；（IP)=标号在段中的偏移地址。 

far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

### 转移地址在寄存器中的jmp指令

指令格式：jmp 16位reg

功能:（IP)=(16 位 reg)

这种指令我们在第二章中已经讲过，这里就不再详述。

### 转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式:

⑴ jmp word ptr 内存单元地址(段内转移)

功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令:

```
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
```

执行后，（IP)=0123H 

又比如，下面的指令：

```
mov ax,0123H 
mov [bx],ax 
jmp word ptr [bx]
```

执行后，（IP)=0123H

⑵ jmp dword ptr 内存单元地址(段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低 地址处是转移的目的偏移地址。
(CS)=(内存单元地址+2) 

(IP)=(内存单元地址）

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令:

```
mov ax,0123H 
mov ds:[0],ax 
mov word ptr ds:[2],0 
jmp dword ptr ds:[0]
```

执行后，（CS)=0，（IP)=0123H, CS:IP 指向 0000:0123

又比如，下面的指令：

```
mov ax,0123H 
mov [bx],ax
mov word ptr [bx+2],0 
jmp dword ptr [bx]
```

执行后，（CS)=0，（IP)=0123H, CS:IP 指向 0000:0123

### jcxz

jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中 包含转移的位移，而不是目的地址。对IP的修改范围都为：-128〜127。
指令格式：jcxz 标号(如果(cx)=0，转移到标号处执行。）
操作：当(cx)=0时，(IP)=(IP)+8位位移；
8位位移=标号处的地址-jcxz指令后的第一个字节的地址；
8位位移的范围为-128〜127,用补码表示；
8位位移由编译程序在编译时算出。
当(cx)≠0时，什么也不做(程序向下执行)。
我们从jcxz的功能中可以看出，“jcxz标号”的功能相当于： if ((cx)==0) jmp short 标号；
(这种用C语言和汇编语言进行的综合描述，或许能使你对有条件转移指令理解得更 加清楚。）

### loop指令

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位 移，而不是目的地址。对IP的修改范围都为：-128〜127。
指令格式：loop标号((CX)=(CX)-1，如果(cx)≠O，转移到标号处执行。）
操作：
(1)	(cx)=(cx)-1;
(2)	如果(cx)≠0, (IP)=(IP)+8 位位移。
8位位移=标号处的地址-loop指令后的第一个字节的地址；
8位位移的范围为-128〜127,用补码表示；
8位位移由编译程序在编译时算出。
如果(cx)=0，什么也不做(程序向下执行)。
我们从loop的功能中可以看出，“loop标号”的功能相当于：
(cx)--;
if ((cx)≠0)  jmp short 标号；

### 根据位移进行转移的意义

前面我们讲到:

jmp short 标号

jmp near ptr 标号 

jcxz 标号 

loop 标号
等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。
这种设计，方便了程序段在内存中的浮动装配。
例如：

```
	汇编指令	机器代码
	mov cx,6	B9	06	00
	mov ax,10h	B8	10	00
s:	add ax,ax	01	CO
	loop s		E2	FC
```

这段程序装在内存中的不同位置都可正确执行，因为loop s在执行时只涉及s的位移 (-4,前移4个字节，补码表示为FCH)，而不是s的地址。如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。而loop s的机器码中 包含的是转移的位移，就不存在这个问题了，因为，无论s处的指令的实际地址是多少， loop指令的转移位移是不变的。

### 编译器对转移位移超界的检测

注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程 序中出现了转移范围超界的问题，在编译的时候，编译器将报错。

比如，下面的程序将引起编译错误：

```
assume cs:code
code segment
	start:jmp short s
		  db 128 dup (0)	
		s:mov ax,0ffffh
code ends
end start
```

jmp shorts的转移范围是-128〜127, IP最多向后移动127个字节。
**注意，我们在第2章中讲到的形如“jmp 2000:0100”的转移指令，是在Debug中使 用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。**

## 十、CALL和RET指令

call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。这一章，我们讲解call和ret指令的原理。

### ret和retf

ret指令用栈中的数据，修改IP的内容，从而实现近转移； 

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。
CPU执行ret指令时，进行下面两步操作：
(1)	(IP)=((ss)\*16+(sp))
(2)	(sp)=(sp)+2
CPU执行retf指令时，进行下面4步操作：
⑴（IP)=(ss)\*16+(sp))
(2)  (sp)=(sp)+2
(3)  (CS)=((ss)*16+(sp))
(4)（sp)=(sp)+2
可以看出，如果我们用汇编语法来解释ret和retf指令，则：
CPU执行ret指令时，相当于进行：

pop IP

CPU执行retf指令时，相当于进行:

pop IP

pop CS

### call指令

CPU执行call指令时，进行两步操作：
(1)	将当前的IP或CS和IP压入栈中；
(2)	转移。
call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同，下面，我们以给出转移目的地址的不同方法为主线，讲解call指令的主要应用格式。

### 依据位移进行转移的call指令

call 标号(将当前的IP压栈后，转到标号处执行指令) 

CPU执行此种格式的call指令时，进行如下的操作：

(1)	(sp)=(sp)-2 

​		 ((ss)*16+(sp)=(IP)
(2)	(IPMIP)+16 位位移。
16位位移=标号处的地址-call指令后的第一个字节的地址；
16位位移的范围为-32768〜32767,用补码表示；
16位位移由编译程序在编译时算出。
从上面的描述中，可以看出，如果我们用汇编语法来解释此种格式的call指令，则: 

CPU执行“call标号”时，相当于进行：
push IP
jmp near ptr 标号

### 转移的目的地址在指令中的call指令

之前说的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。
“call far ptr标号”实现的是段间转移。
CPU执行此种格式的call指令时，进行如下的操作。
(1)	(sp)=(sp)-2
		 ((ss)\*16+(sp))=(CS)	
		 (sp)=(sp)-2
		 ((ss)*16+(sp)=(IP)
(2)	(CS)=标号所在段的段地址 〇P)=标号在段中的偏移地址
从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的call指令，则：
CPU执行“callfarptr标号”时，相当于进行：
push CS 

push IP

jmp far ptr 标号

### 转移地址在寄存器中的call指令

指令格式：call 16位reg

功能：

(sp)=(sp)-2
((ss)*16+(sp)=(IP)
(IP)=(16 位 reg)

用汇编语法来解释此种格式的call指令，CPU执行“call 16位reg”时，相当于 进行：

push IP 

jmp 16 位 reg

### 转移地址在内存中的call指令

转移地址在内存中的call指令有两种格式。

(1) call word ptr内存单元地址 

用汇编语法来解释此种格式的call指令，则：
CPU执行“call word ptr内存单元地址”时，相当于进行:
push IP
jmp word ptr内存单元地址
比如，下面的指令:

```
mov sp,10h 
mov ax,0123h 
mov ds:[0],ax
call word ptr ds:[0]
```

执行后，（IP）=0123H，（sp）=0EH

(2) call dword ptr内存单元地址 用汇编语法来解释此种格式的call指令，则:
CPU执行“call dword ptr内存单元地址”时，相当于进行:
push CS 

push IP

jmp dword ptr内存单元地址

比如，下面的指令：

```
mov sp,10h
mov ax,0123h 
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
```

执行后,CS)=0,（IP)=0123H, (sp)=0CH。

### call和ret的配合使用

我们可以利用call和ret来实现子程序的机制。子程序的框架如下。
标号：
	指令
	ret
具有子程序的源程序的框架如下。

```
assume cs:code 
code segment 
	main: :
		  :
		  call subl				;调用子程序subl
		  :
		  :
		  mov ax,4c00h 
		  int 21h
		  
	subl: :						;子程序subl开始
		  :
		  call sub2			    ;调用子程序sub2
		  :						
		  :
		  ret 程序返回			  ;子程序返回
		  
	sub2: :						 ;子程序sub2开始
    	  :
    	  :
    	  ret				  	 ;子程序返回
code ends
end main
```

### mul指令

mul是乘法指令，使用mul做乘法的时候， 注意以下两点。
(1) 两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位， —个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认在 AX中，另一个放在16位reg或内存字单元中。
(2)	结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默 认在DX中存放，低位在AX中放。
格式如下:

mul reg 

mul 内存单元

内存单元可以用不同的寻址方式给出，比如:

mul byte ptr ds:[0]

含义:（ax)=(al)\*((ds)\*6+0);

mul word ptr \[bx+si+8\]

含义:	(ax)=(ax)\*((ds)\*16+(bx)+(si)+8)结果的低 16 位。 

​			 (dx)=(ax)\*((ds)*16+(bx)+(si)+8)结果的高 16 位。

例：

(1)计算 100*10。

100和10小于255,可以做8位乘法，程序如下。

mov al,100 

mov bl,10 

mul bl

结果：（ax)=1000(03E8H)

(2)计算 100*10000

100小于255，可10000大于255，所以必须做16位乘法，程序如下。

mov ax,100 

mov bx,10000

mul bx

结果：（ax)=4240H, (dx)=000FH	(F4240H=1000000)

## 十一、标志寄存器

**补充知识：**

**原码、反码、补码**

**原码：**

**原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:**

```
[+1]原 = 0000 0001
[-1]原 = 1000 0001
```

**第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：**

```
[1111 1111 , 0111 1111]
```

**即**

```
[-127 , 127]
```

**反码：**

**反码的表示方法是:**

**正数的反码是其本身**

**负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.**

```
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
```

**补码：**

**补码的表示方法是:**

**正数的补码就是其本身**

**负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)**

```
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

CPU内部的寄存器中，有一种特殊的寄存器(对于不同的处理机，个数和结构都可能不同)具有以下3种作用。

1、用来存储相关指令的某些执行结果

2、用来为CPU执行相关指令提供行为依据

3、用来控制CPU的相关工作方式

这种特殊的寄存器在8086CPU中，被称为标志寄存器。8086CPU的标志寄存器有16 位，其中存储的信息通常被称为程序状态字(PSW)。我们已经使用过8086CPU的ax、 bx、cx、dx、si、di、bp、sp、IP、cs、ss、ds、es等13个寄存器了，本章中的标志寄存 器(以下简称为flag)是我们要学习的最后一个寄存器。
flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个 含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

8086CPU的flag寄存器的结构如图11.1所示

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-02-04_18-35-23.png)

flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而 0、2、4、6、7、8、9、10、11位都具有特殊的含义。
在这一章中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，以及一 些与其相关的典型指令。

### ZF（Zero Flag）

flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF=1。如果结果不为0，那么zf=0。
比如，指令：

mov ax,1

sub ax,1

执行后结果为0，则ZF=1

mov ax,2

sub ax,1

执行后结果不为0，则ZF=0

对于zf的值，我们可以这样来看，zf标记相关指令的计算结果是否为0,如果为0, 则zf要记录下“是0”这样的肯定信息。在计算机中1表示逻辑真，表示肯定，所以当结果为0的时候zf=1,表示“结果是0”。如果结果不为0,则zf要记录下“不是0”这样 的否定信息。在计算机中0表示逻辑假，表示否定，所以当结果不为0的时候zf=0，表示 “结果不是0” 。

比如，指令：

mov ax,1

and ax,0

执行后结果为0，则ZF=1，表示结果是“0”。

mov ax,1

or ax,0

执行后结果不为0，则ZF=0，表示结果不为“0”。

注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、 sub、mul、div、inc、or、and等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪 些标志位造成影响。

### PF（Parity Flag）

flag的第2位是PF,奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1 的个数是否为偶数。如果1的个数为偶数，pf=l，如果为奇数，那么pf=0。
比如，指令：

mov al,1

add al,10

执行后，结果为00001011B，其中有3(奇数)个1,则pf=0;

mov al,1

or al,2

执行后，结果为00000011B，其中有2(偶数)个1，则pf=1;

sub al,al

执行后，结果为00000000B，其中有0(偶数)个0，则pf=1。

### SF（Sign Flag）

flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果 结果为负，sf=1;如果非负，sf=0。
计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数， 也可以看成是无符号数。比如：
00000001B，可以看作为无符号数1,或有符号数+1;
10000001B，可以看作为无符号数129,也可以看作有符号数-127。
这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可 以当作有符号数据来运算。比如：

mov al,10000001B 

add al,1

结果：（al)=l0000010B。
可以将add指令进行的运算当作无符号数的运算，那么add指令相当于计算129+1, 结果为130(10000010B);也可以将add指令进行的运算当作有符号数的运算，那么add指 令相当于计算-127+1，结果为-126(10000010B)。
不管我们如何看待，CPU在执行add等指令的时候，就己经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。
SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。

这也就是说，CPU在执行add等指令时，是必然要影响到SF标志位的值的。至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。
比如：

mov al,10000001B 

add al,1

执行后，结果为10000010B，sf=1,表示：如果指令进行的是有符号数运算，那么结果为负；

mov al,10000001B

add al,01111111B

执行后，结果为0, sf=0,表示：如果指令进行的是有符号数运算，那么结果为非负。
某些指令将影响标志寄存器中的多个标记位，这些被影响的标记位比较全面地记录了 指令的执行结果，为相关的处理提供了所需的依据。比如指令sub al,al执行后，ZF、PF、 SF等标志位都要受到影响，它们分别为：1、1、0。

**问题：**

写出下面每条指令执行后，		ZF、PF、	SF等标志位的值。
sub al,al	ZF=	PF=	SF=
mov al,1    ZF=	PF=	SF=
push ax	 ZF=	PF=	SF=
pop bx	   ZF=	PF=	SF=
add al,bl	ZF=	PF=	SF=
add al,10   ZF=	PF=	SF=
mul al		ZF=	PF=	SF=

### CF（Carry Flag）

flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位，如图11.2 所示。

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-02-04_20-27-37.png)

我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。比如，两个8位数据：98H+98H，将产生进位。由于这个进位值在8位数中无法保存，之前就只是简单地说这个进位值丢失了。其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来 记录这个进位值。比如，下面的指令：

`mov al,98H`

`add al,al	;执行后：(al)=30H，CF=1, CF记录了从最高有效位向更高位的进位值`

`add al,al	;执行后：（al>=6〇H, CF=0, CF记录了从最髙有效位向更高位的进位值`

而当两个数据做减法的时候，有可能向更高位借位。比如，两个8位数据：97H-98H，将产生借位，借位后，相当于计算197H-98H。而flag的CF位也可以用来记录这个借位值。比如，下面的指令：

`mov al,97H`
`sub al,98H	;执行后：（al）=FFH, CF=1, CF记录了向更高位的借位值`
`sub al,al	;执行后：（al）=0, CF=0, CF记录了向更髙位的借位值`

### OF（Overflow Flag）

flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1;如果没有，OF=0。
—定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。比如：
`mov al,98 `

`add al,99`
add指令执行后：CF=0, OF=1。前面我们讲过，CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。对于无符号数运算，98+99没有进位，CF=0;对于有符号数运算，98+99发生溢出，OF=l。
`mov al,0F0H`

`add al,88H`
add指令执行后：CF=1，OF=1。对于无符号数运算，0F0H+88H有进位，CF=1;对 于有符号数运算，0F0H+88H发生溢出，OF=1。

`mov al,0F0H`

`add al,78H`

add指令执行后：CF=1, OF=0。对于无符号运算，0F0H+78H有进位，CF=1;对于有符号数运算，0F0H+78H不发生溢出，OF=0。
我们可以看出，CF和OF所表示的进位和溢出，是分别对无符号数和有符号数运算而言的，它们之间没有任何关系。

### adc指令

adc是带进位加法指令，它利用了 CF位上记录的进位值。

指令格式：adc操作对象1，操作对象2 

功能：操作对象1 =操作对象1 +操作对象2 + CF 

比如指令adc ax,bx    实现的功能是：（ax)=(ax)+(bx)+CF

例:

mov ax,2

mov bx,1

sub bx,ax

adc ax,1

执行后,（ax)=4。adc执行时，相当于计算：（ax)+1+CF=2+1+1=4。

mov ax,1 

add ax,ax 

adc ax,3

执行后,（ax)=5。adc执行时，相当于计算：（ax)+3+CF=2+3+0=5。

mov al,98H 

add al,al 

adc al,3
执行后，（al)=34H。adc 执行时，相当于计算：（al)+3+CF=30H+3+l=34H。 可以看出，adc指令比add指令多加了一个CF位的值。
为什么要加上CF的值呢？ CPU为什么要提供这样一条指令呢？

先来看一下CF的值的含义。在执行adc指令的时候加上的CF的值的含义，是由adc 指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。显 然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设 置的，那么它的含义就是进位值。我们来看一下两个数据：0198H和0183H如何相 加的：
		01	98

​		01	83

——————

​		03    1B

可以看出，加法可以分两步来进行：①低位相加；②高位相加再加上低位相加产生的 进位值。
下面的指令和add ax，bx具有相同的结果：

add al,bl 

adc ah,bh

看来CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指 令相配合就可以对更大的数据进行加法运算。我们来看一个例子：
编程，计算1EF000H+201000H，结果放在ax(高16位)和bx(低16位)中。
因为两个数据的位数都大于16,用add指令无法进行计算。我们将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。程序如下。

```
mov ax,001EH 
mov bx,0F000H 
add bx,1000H 
adc axf0020H
```

adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。由于有这样的功能，我们就可以对任意大的数据进行加法运算。看一个例子：

### sbb指令

sbb是带借位减法指令，它利用了 CF位上记录的借位值。
指令格式：sbb操作对象1，操作对象2 功能：操作对象1=操作对象1-操作对象2-CF 比如指令sbbax，bx实现的功能是：（ax)=(ax)-(bx)-CF
sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运 算。比如，计算003E1000H-00202000H,结果放在ax，bx中，程序如下：

```
mov bx,1000H 
mov ax,003EH 
sub bx,2000H 
sbb ax,0020H
```

sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。

### cmp指令

cmp是比较指令，onp的功能相当于减法指令，只是不保存结果。cmp指令执行后， 将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。
cmp指令格式：cmp操作对象1，操作对象2
功能：计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。
比如，指令cmp ax，ax，做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响 flag的相关各位。指令执行后：zf=l，pf=l，sf=0, cf=0，of=0。
下面的指令：

```
mov ax,8
mov bx,3
cmp ax,bx
```

执行后：(ax)=8，zf=0, pf=l，sf=0，cf=0，of=0。
其实，我们通过cmp指令执行后，相关标志位的值就可以看出比较的结果。

cmp ax,bx

如果(ax)=(bx) 则(ax)-(bx)=0,所以：zf=1;
如果(ax)≠(bx) 则(ax)-(bx)≠0,所以：zf=0;
如果(ax)<(bx) 则(ax)-(bx)将产生借位,所以：cf=l;
如果(ax)≥(bx) 则(ax)-(bx)不必借位,所以：cf=0;
如果(ax)>(bx) 则(ax)-(bx)既不必借位,结果又不为0,所以：cf=0并且zf=0;
如果(ax)≤(bx) 则(ax)-(bx)既可能借位,结果可能为0,所以：cf=l或zf=l。
现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。反过来看上面的例子。
指令cmp ax,bx的逻辑含义是比较ax和bx中的值，如果执行后：

zf=1,说明(ax)=(bx)
zf=0,说明(ax)≠(bx)
cf=1,说明(ax)<(bx)
cf=0,说明(ax)≥(bx)
cf=0 并且 zf=0,说明(ax)>(bx)
cf=1或zf=1,说明(ax)≤(bx)
同add、sub指令一样，CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。上面所讲的是用cmp进行无符号数比较时，相关标志位对比较结果的 记录。下面我们再来看一下如果用cmp来进行有符号数比较时，CPU用哪些标志位对比较结果进行记录。我们以cmp ah,bh为例进行说明。
cmp ah,bh
如果(ah)=(bh) 则(ah)-(bh)=0,所以：zf=l;
如果(ah)≠(bh) 则(ah)-(bh)≠0,所以：zf-0;
所以，根据cmp指令执行后zf的值，就可以知道两个数据是否相等。
我们继续看，如果(ah)<(bh)则可能发生什么情况呢？
对于有符号数运算，在(ah)<(bh)情况下,（ah)-(bh)显然可能引起sf=1，即结果为负。

比如：

(ah)=1,(bh)=2;则(ah)-(bh)=0FFH, 0FFH 为-1 的补码,因为结果为负,所以 sf=1。

(ah)=0FEH,(bh)=0FFH;则(ah)-(bh)=-2-(-1)=0FFH,因为结果为负,所以 sf=1。

通过上面的例子，我们是不是可以得到这样的结论：cmp 操作对象1,操作对象2 指令执行后，sf=1，就说明操作对象1<操作对象2?
显然不是

再看两个例子。
(ah)=22H，（bh)=0A0H;则(ah)-(bh)=34-(-96)=82H，82H 是-126 的补码 所以sfW
这里虽然sf=1,但是并不能说明(ah)<(bh)因为显然34>-96。
两个有符号数A和B相减，得到的是负数，那么可以肯定A<B，这个思路没有错误，关键在于我们根据什么来断定得到的是一个负数。CPU将cmp指令得到的结果记录在flag的相关标志位中。我们可以根据指令执行后，相关标志位的值来判断比较的结果。 单纯地考查sf的值不可能知道结果的正负。因为sf记录的只是可以在计算机中存放的相 应位数的结果的正负。比如add ah,al执行后，sf记录的是ah中的8位二进制信息所表示 的数据的正负。cmp ah，bh执行后，sf记录的是(ah)-(bh)所得到的8位结果数据的正负， 虽然这个结果没有在我们能够使用的寄存器或内存单元中保存，但是在指令执行的过程 中，它暂存在CPU内部的暂存器中。
所得到的相应结果的正负，并不能说明，运算所应该得到的结果的正负。这是因为在运算的过程中可能发生溢出。如果有这样的情况发生，那么，sf的值就不能说明任何问题。比如：

```
mov ah,22H
mov bh,0A0H 
sub ah,bh
```

结果sf=l，运算实际得到的结果是(ah)=82H，但是在逻辑上，运算所应该得到的结果 是：34-(-96)=130。就是因为130这个结果作为一个有符号数超出了-128〜127这个范围， 在ah中不能表示，而ah中的结果被CPU当作有符号数解释为-126。而sf被用来记录这个实际结果的正负，所以sf=1。但sf=1不能说明在逻辑上，运算所得的正确结果的正负。

又比如：

```
mov ah,08AH 
mov bh,070h 
cmp ah,bh
```

结果sf=0，运算(ah)-(bh)实际得到的结果是1AH,但是在逻辑上，运算所应该得到的结果是:(-118)-112=-230。sf记录实际结果的正负，所以sfH)。但sfN)不能说明在逻辑 上，运算所得的正确结果。
但是逻辑上的结果的正负，才是cmp指令所求的真正结果，因为我们就是要靠它得 到两个操作对象的比较信息。所以cmp指令所作的比较结果，不是仅仅靠sf就能记录 的，因为它只能记录实际结果的正负。
我们考虑一下，两种结果之间的关系，实际结果的正负，和逻辑上真正结果的正负， 它们之间有多大的距离呢？从上面的分析中，我们知道，实际结果的正负，之所以不能说明逻辑上真正结果的正负，关键的原因在于发生了溢出。如果没有溢出发生的话，那么， 实际结果的正负和逻辑上真正结果的正负就一致了。
所以，我们应该在考査sf(得知实际结果的正负)的同时考查of(得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。
下面，我们以cmp ah,bh为例，总结一下CPU执行cmp指令后，sf和of的值是如何来说明比较的结果的。
(1)如果sf=1，而 of=0
of=0,说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因sf=1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)<(bh)。
(2)如果 sf=1，而 of=1:
of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；因sf=1，实际结果为负。实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，简单分析一 下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。
这样，sf=l，of=l，说明了(ah)>(bh)。
(3)如果 sf=0，而 of=1
of=l，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；因sf=0,实际结果非负。而of=1说明有溢出，则结果非0,所以，实际结果为正。 实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，简单分析一 下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。 这样，sf=0，of=l，说明了(ah)<(bh)。
(4)如果 sf=0，而 of=0
of=0,说明没有溢出，逻辑上真正结果的正负=实际结果的正负；因sf=0,实际结果非负，所以逻辑上真正的结果非负，所以(ah)≥(bh)。
上面，我们深入讨论了 cmp指令在进行有符号数和无符号数比较时，对flag相关标志位的影响，和CPU如何通过相关的标志位来表示比较的结果。在学习中，要注意领会 8086CPU这种工作机制的设计思想。实际上，这种设计思想对于各种处理机来说是普遍的。

**总结：**

1、sf=1,of=0	(ah)<(bh)

2、sf=1,of=1	(ah)>(bh)	

3、sf=0,of=1	(ah)<(bh)

4、sf=0,of=0	(ah)≥(bh)

### 检测比较结果的条件转移指令

这个直接看这个图就可以了，不做过多解释，使用的时候看图就行，看多了就能记住了。图片出处小甲鱼。

![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93.gif)

### DF标志（Direction Flag）和串传送指令

flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。
dI=0	每次操作后si、di递增； 
df=1	每次操作后si、di递减。
我们来看下面的一个串传送指令。
格式：movsb
功能：执行movsb指令相当于进行下面几步操作。
(1)	((es)*16+(di)H(ds)*16+(si»
(2)	如果 df=0 则： （si)=(si)+l
                                      (di)=di)+l

用汇编语法描述movsb的功能如下。
mov es:[di],byte ptr ds:[si]	;8086并不支持这样的指令，这里只是个描述
如果df=0: 
inc si 
inc di
如果df=l: 
dec si 
dec di
可以看出，movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减。
当然，也可以传送一个字，指令如下。
格式：movsw
movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器 df位的值，将si和di递增2或递减2。
用汇编语法描述movsw的功能如下。
mov es:[di],word ptr ds:[si]	;8086并不支持这样的指令，这里只是个描述
如果df=0: 
add si,2 
add di,2
如果df=1:
sub si,2
sub di,2
movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：.
rep movsb
用汇编语法来描述rep movsb的功能就是：
s: movsb 
  loop s
可见，rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次 movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循 环实现(cx)个字符的传送。
同理，也可以使用这样的指令：rep movsw。
相当于:
s: movsw
  loop s
由于flag的df位决定着串传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使程序员能够决定传送的方向。
8086CPU提供下面两条指令对df位进行设置。
cld指令：将标志寄存器的df位置0 
std指令：将标志寄存器的df位置1

### pushf和popf

pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。
pushf和popf，为直接访问标志寄存器提供了一种方法。

### 标志寄存器在Debug中的表示

在Debug中，标志寄存器是按照有意义的各个标志位单独表示的。在Debug中，我们可以看到下面的信息。
![](https://resery-tuchuang.oss-cn-beijing.aliyuncs.com/2020-02-09_14-12-53.png)                                      

下面列出Debug对我们己知的标志位的表示。
标志	值为1的标记	值为0的标记
of	         OV				NV
sf		NG			       PL
zf		ZR			        NZ
pf	         PE				 PO
cf		CY			        NC
df	         DN			         UP

## 十六、直接定址表

### 描述了单元长度的标号

之前，我们一直在代码段中使用标号来标记指令、数据、段的起始地址。比如，下面的程序将code段中的a标号处的8个数据累加，结果存储到b标号处的字中。

```
assume cs:code
code segment
		a: db 1,2,3,4,5,6,7,8 
		b: dw 0
		
start: mov si,offset a 
	   mov bx,offset b 
	   mov cx,8
	   
s: 	   mov al,cs:[si] 
	   mov ah,0 
	   add cs:[bx],ax 
	   inc si 
	   loop s
	   
	   mov ax,4c00h 
	   int 21h
	   
code ends 
end start
```

程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址。
在code段中使用的标号a、b后面不加" ："，它们是同时描述内存地址和单元长度的标号。标号a,描述了地址code:0,和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code:8,和从这个地址开始，以后的内存单元都是字单元.
因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。

### 在其他段中使用数据标号

一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中, 我们也可以使用数据标号来描述存储数据的单元的地址和长度。
注意，在后面加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用。
注意，如果想在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。我们在程序中还要使用指令对段寄存器进行设置。
比如，我们要在代码段code中用data段中的数据标号a、b访问数据，则必须用assume将一个寄存器和data段相联。在程序中，我们用ds寄存器和data段相联。
因为这些实际编译出的指令，都默认所访问单元的段地址在ds中，而实际要访问的段为data,所以若要访问正确，在这些指令执行前，ds中必须为data段的段地址。则我们在程序中需要设置ds指向data段。可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。
**补充：seg操作符，功能为取得某标号的段地址。**

### 直接定址表

现在，我们讨论用査表的方法编写相关程序的技巧。
编写子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。
分析：一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个 ASCII字符。我们当然要用 “0”、“1”、“2”、“3”、“4”、“5”、“6”、 “7”、“8”、“9”、“A”、“B”、“C”、“D”、“E”、“F” 这 16 个字符来显示十六进制数码。
我们可以将一个字节的高4位和低4位分开，分别用它们的值得到对应的数码字符。 比如2Bh,可以得到高4位的值为2,低4位的值为11，那么如何用这两个数值得到对应的数码字符“2”和“B”呢？
最简单的办法就是一个一个地比较，如下：
如果数值为0,则显示“0” ；
如果数值为1，则显示“1”；
如果数值为11，则显示“B”；
我们可以看出，这样做，程序中要使用多条比较、转移指令.程序将比较长，混乱.
显然，我们希望能够在数值0-15和字符“0” ~ “F”之间找到一种映射关系。这样用0\~15间的任何数值，都可以通过这种映射关系直接得到“0” ~ “F”中对应的字符。
数值0\~9和字符“0” ~ “9”之间的映射关系是很明显的，即: 数值+30h=对应字符的ASCII值
0+30h= “0” 的 ASCII 值
1+30h= “1” 的 ASCII 值 
2+30h= “2” 的 ASCII 值
但是，10\~15和“A”〜“F”之间的映射关系是:
数值+37h=对应字符的ASCII值 
10+37h= “A” 的 ASCII 值 
11+37h= “B” 的 ASCII 值 
12+37h= “C” 的 ASCII 值
可见，我们可以利用数值和字符之间的这种原本存在的映射关系，通过高4位和低4位值得到对应的字符码。但是由于映射关系的不同，我们在程序中必须进行一些比较，对于大于9的数值，我们要用不同的计算方法。
这样做，虽然使程序得到了简化。但是，如果我们希望用更简捷的算法，就要考虑用同一种映射关系从数值得到字符码。所以，我们就不能利用0\~9和“0” ~ “9”之间与 10\~15和“A”〜“F”之间原有的映射关系。
因为数值0\~15和字符“0” ~ “F”之间没有一致的映射关系存在，所以，我们应该在它们之间建立新的映射关系。
具体的做法是，建立一张表，表中依次存储字符“0” ~ “F”，我们可以通过数值 0-15直接査找到对应的字符。
**补充：建表的语法是 table 数据类型 ‘xxxx’。**
我们在数值0~15和字符“0” ~ “F”之间建立的映射关系为：以数值N为table表中的偏移，可以找到对应的字符。
利用表，在两个数据集合之间建立一种映射关系，使我们可以用査表的方法根据给出的数据得到其在另一集合中的对应数据。这样做的目的一般来说有以下3个。
(1) 为了算法的清晰和简洁；
(2) 为了加快运算速度；
(3) 为了使程序易于扩充。
